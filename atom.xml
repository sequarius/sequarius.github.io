<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sequarius</title>
  <subtitle>A boy without story</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sequarius.com/"/>
  <updated>2018-11-06T13:50:24.137Z</updated>
  <id>https://www.sequarius.com/</id>
  
  <author>
    <name>Sequarius</name>
    <email>sequarius@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JShell源码解读，REPL实现分析</title>
    <link href="https://www.sequarius.com/2017/10/22/JShell%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%8CJava-REPL%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>https://www.sequarius.com/2017/10/22/JShell源码解读，Java-REPL实现分析/</id>
    <published>2017-10-22T13:04:24.000Z</published>
    <updated>2018-11-06T13:50:24.137Z</updated>
    
    <content type="html"><![CDATA[<p>Java9不出意外的又跳票了，传闻Java9加入了<a href="http://openjdk.java.net/jeps/222" target="_blank" rel="external">JEP 222</a>，所以用OpenJDK体验了一把JShell并分析了下其实现。</p>
<h3 id="JShell简述"><a href="#JShell简述" class="headerlink" title="JShell简述"></a>JShell简述</h3><p>JShell是一个能够执行Java代码片段、表达式的Shell，从外表看上去像是一个Java的解释器，实际上它是一个Read-Eval-Print Loop，接受命令、代码片段输入，输出运算结果或者一个变更状态。</p>
<h3 id="JShell简易使用指北"><a href="#JShell简易使用指北" class="headerlink" title="JShell简易使用指北"></a>JShell简易使用指北</h3><ol>
<li>通过${JAVA_HOME}/bin/jshell便可以启动一个JShell。</li>
<li>如其他Java工具一样，JShell已自带普通话补丁，在其OepnJDK源码资源文件也可以看到有<code>l10n_zh_CN.properties</code>的多语言支持。</li>
<li>执行命令<br>类似于IPython，JShell除了可以执行Java代码，还内置了部分命令，键入<code>\help</code>便可以获得命令列表。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/image/jshell_command_list.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></li>
<li>表达式执行<br>JShell可以直接执行一个算术表达式，输出计算值或者函数的返回值。对于单条语句，可以省略句尾句号<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/image/jshell_eval_express.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></li>
<li>import<br>JShell同时可以支持import外部包，使用Tab进行自动补全等功能。这里import还可以使用<code>\evn</code>指令导入的合法classpath下的任意jar。也就是说导入<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/image/jshell_import_express.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></li>
<li>类创建初始化<br>JShell同时可以创建初始化类实例，调用实例方法。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/image/jshell_class_express.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
</ol>
<h3 id="JShell基础对象"><a href="#JShell基础对象" class="headerlink" title="JShell基础对象"></a>JShell基础对象</h3><h4 id="MemoryFileManager"><a href="#MemoryFileManager" class="headerlink" title="MemoryFileManager"></a>MemoryFileManager</h4><p>JShell编译器内存文件API的管理器，同时具有一个OutputMemoryJavaFileObject的Map用于类文件的缓存。</p>
<h4 id="TaskFactory"><a href="#TaskFactory" class="headerlink" title="TaskFactory"></a>TaskFactory</h4><p>编译器用于解析、分析、在内存编译class文件的API基本接口，其中CompileTask、AnalyzeTask、ParseTask均继承自BaseTask，这几个Task均为TaskFactory的内部类，通过TaskFactory的工厂方法产生对应的实例。</p>
<h4 id="Eval"><a href="#Eval" class="headerlink" title="Eval"></a>Eval</h4><p>赋值引擎，将source 封装成方法、属性等等，在外部封装了imports和class，为整个JShell的核心部分</p>
<p>编译 声明 重定义 替换 执行</p>
<h4 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h4><p>代表传递的Java代码片段，同一个片段是不可变的，这一特性也就意味着它的任意方法都会有相同的返回，并且是线程安全的。<br>Snippet为抽象类，只有继承终点为实现类，其中派生Snippet结构如图所示。<br>ExpressionSnippet为表达式片段，StatementSnippet为声明片段，ErroneousSnippet为非法片段，PersistentSnippet为被存储影响后续代码结果的片段。DeclarationSnippet为值片段，其下属值、类型、函数都是其实现类。</p>
<h4 id="SnippetEvent"><a href="#SnippetEvent" class="headerlink" title="SnippetEvent"></a>SnippetEvent</h4><p>直接/间接通过 JShell.eval(String)或者JShell.drop(Snippet), 或者Snippet被直接生成的关于这个变化描述的片段</p>
<h4 id="ReplParserFactory"><a href="#ReplParserFactory" class="headerlink" title="ReplParserFactory"></a>ReplParserFactory</h4><p>继承自<code>com.sun.tools.javac.parser.ParserFactory</code>解析器工厂，通过<code>com.sun.tools.javac.util.Context</code>初始化了,<code>com.sun.tools.javac.parser.ScannerFactory</code>用于产生Scanner。</p>
<h4 id="DiagList"><a href="#DiagList" class="headerlink" title="DiagList"></a>DiagList</h4><p>一个存放Snippet诊断信息的向量，这些包含是否有不可达、未声明、无法解析等错误。</p>
<h4 id="MaskCommentsAndModifiers"><a href="#MaskCommentsAndModifiers" class="headerlink" title="MaskCommentsAndModifiers"></a>MaskCommentsAndModifiers</h4><p>对一个输入的String，通过Context隐藏其注释和修饰符细节。</p>
<h4 id="Warp"><a href="#Warp" class="headerlink" title="Warp"></a>Warp</h4><p>将源输入包装成方法，成员变量，等等。</p>
<h3 id="JShell源码分析"><a href="#JShell源码分析" class="headerlink" title="JShell源码分析"></a>JShell源码分析</h3><p>由于时间有限，这里先把程序的主要执行逻辑写在这里，以后有时间绘成流程图。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">JShell.eval(String input) throws IllegalStateException</div><div class="line">    -》Eval.eval(String userSource) throws IllegalStateException</div><div class="line">    //初始化</div><div class="line">    -》List&lt;SnippetEvent&gt; allEvents</div><div class="line">    -》Eval sourceToSnippets(String userSource)</div><div class="line">    -》分析语句、通过MaskCommentsAndModifiers隐藏修饰符细节，通过工具类分析行尾，组成可以被编译的语句</div><div class="line">    -》创建ParseTask进行语义分析获得分析树List&lt;? extends Tree&gt; units</div><div class="line">    -》分析units首语句类型，进入对应执行模块</div><div class="line">        -》解剖unit Eval.processVariables(String userSource, List&lt;? extends Tree&gt; units, String compileSource, ParseTask pt)</div><div class="line">            -》TreeDissector.createByFirstClass(TaskFactory.BaseTask bt)</div><div class="line">                -》static TreeDissector createByFirstClass(TaskFactory.BaseTask bt) &#123;</div><div class="line">                    Pair&lt;CompilationUnitTree, ClassTree&gt; pair = classes(bt.firstCuTree())</div><div class="line">                    .findFirst().orElseGet(() -&gt; new Pair&lt;&gt;(bt.firstCuTree(), null));</div><div class="line">                    return new TreeDissector(bt, pair.first, pair.second);</div><div class="line">                    &#125;</div><div class="line">            -》根据遍历units,获取Variable基本类型、变量名、基类</div><div class="line">                VariableTree vt = (VariableTree) unitTree;</div><div class="line">                String name = vt.getName().toString();</div><div class="line">                String typeName = EvalPretty.prettyExpr((JCTree) vt.getType(), false);</div><div class="line">                Tree baseType = vt.getType();</div><div class="line">            -》扫描语义依赖TreeDependencyScanner.scan(Tree node) </div><div class="line">            -》通过VariableTree.getInitializer();获得ExpressionTree</div><div class="line">            -》Wrap.varWrap(String source, Range rtype, String brackets, Range rname, Range rinit)</div><div class="line">    -》allEvents.addAll(declare(snip, snip.syntheticDiags()));</div></pre></td></tr></table></figure></p>
<h3 id="JShell-eval"><a href="#JShell-eval" class="headerlink" title="JShell eval"></a>JShell eval</h3><p>通过以上源码分析，我们我们可以通过建立一个JShell对象来尝试执行一个简单的Java程序块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JShellTry</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;SnippetEvent&gt; evals = JShell.create().eval(<span class="string">"System.out.print(\"xdsjsd\");"</span>);</div><div class="line">        evals.forEach(evals-&gt; System.out.println(evals.value()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然执行过程稍微长了一点，但是程序成功输出了xdsjsd，实验成功。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JShell为开发者提供了一个稳定的交互式终端，程序开发者可以通过JShell进行一些简单的程序执行结果验证，同时它还赋予了Java应用程序动态执行Java代码的能力，如果不出意外接下来会有很多基于JShell机制的Virtual Runtime，OJ平台出现，大家拭目以待吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java9不出意外的又跳票了，传闻Java9加入了&lt;a href=&quot;http://openjdk.java.net/jeps/222&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JEP 222&lt;/a&gt;，所以用OpenJDK体验了一把JShell并分析了下
    
    </summary>
    
    
      <category term="JShell" scheme="https://www.sequarius.com/tags/JShell/"/>
    
      <category term="REPL" scheme="https://www.sequarius.com/tags/REPL/"/>
    
      <category term="Java" scheme="https://www.sequarius.com/tags/Java/"/>
    
      <category term="JDK9" scheme="https://www.sequarius.com/tags/JDK9/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp开启SSL证书支持</title>
    <link href="https://www.sequarius.com/2017/08/06/OKHttp%E5%BC%80%E5%90%AFSSL%E8%AF%81%E4%B9%A6%E6%94%AF%E6%8C%81/"/>
    <id>https://www.sequarius.com/2017/08/06/OKHttp开启SSL证书支持/</id>
    <published>2017-08-06T03:23:33.000Z</published>
    <updated>2017-08-06T04:00:55.984Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，遇到了一个微信支付调用Rest接口需要SSL授信的问题，遂看了一段时间自SSL证书的集成方式。</p>
<h3 id="Java对安全证书的支持"><a href="#Java对安全证书的支持" class="headerlink" title="Java对安全证书的支持"></a>Java对安全证书的支持</h3><p>JDK在<code>java.security</code>下有一个<code>KeyStore</code>的工具类，可以通过工厂方法<code>getInstance(String type, String provider)</code>初始化一个密钥存储对象，该对象对主流的密钥格式，如PKCS12、PEM都有了默认支持。</p>
<p>以下是初始化密钥的方法描述。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String KEYSTORE_TYPE = <span class="string">"PKCS12"</span>;</div><div class="line"><span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(certPath)) &#123;</div><div class="line">    <span class="comment">// 实例化密钥库</span></div><div class="line">    KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE);</div><div class="line">    <span class="comment">// 加载密钥库</span></div><div class="line">    ks.load(fis, certPass.toCharArray());</div><div class="line">    <span class="comment">// 实例化密钥库</span></div><div class="line">    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</div><div class="line">        <span class="comment">// 初始化密钥工厂</span></div><div class="line">    kmf.init(ks, certPass.toCharArray());</div><div class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(e.getMessage(), e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SSLSocketFactory"><a href="#SSLSocketFactory" class="headerlink" title="SSLSocketFactory"></a>SSLSocketFactory</h3><p>有了密钥，在应用上加解密的配置便完成了，可以使用密钥工厂对SSLSocket进行适配，产生安全连接。使用<code>SSLContext</code>可以初始化一个SSLSocketFactory。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String PROTOCOL_TYPE = <span class="string">"SSL"</span>;</div><div class="line">SSLContext sslContext = SSLContext.getInstance(PROTOCOL_TYPE, <span class="string">"SunJSSE"</span>);</div><div class="line">sslContext.init(kmf.getKeyManagers(), <span class="keyword">null</span>, <span class="keyword">new</span> SecureRandom());</div><div class="line"><span class="comment">// 获取SSLSocketFactory对象</span></div><div class="line">SSLSocketFactory ssf = sslContext.getSocketFactory();</div></pre></td></tr></table></figure></p>
<p>至此，整个SSL连接已经构建完成。</p>
<h3 id="OkHttp使用SSLSocketFactory"><a href="#OkHttp使用SSLSocketFactory" class="headerlink" title="OkHttp使用SSLSocketFactory"></a>OkHttp使用SSLSocketFactory</h3><p><code>OkHttpClient.Builder()</code>提供了一个<code>public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory, X509TrustManager trustManager)</code>方法可以给OKhttp配置一个SSL连接工厂，所有通过该Client的Request都会附带认证信息，其中X509TrustManager为X509密钥标准的抽象管理类。</p>
<p>OKhttp的文档中提供了X509TrustManager的初始化方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</div><div class="line">trustManagerFactory.init((KeyStore) <span class="keyword">null</span>);</div><div class="line">TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</div><div class="line"><span class="keyword">if</span> (trustManagers.length != <span class="number">1</span> || !(trustManagers[<span class="number">0</span>] <span class="keyword">instanceof</span> X509TrustManager)) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected default trust managers:"</span></div><div class="line">        + Arrays.toString(trustManagers));</div><div class="line">     &#125;</div><div class="line">    X509TrustManager trustManager = (X509TrustManager) trustManagers[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<p>最后通过<code>OkHttpClient okHttpClient = new OkHttpClient.Builder().sslSocketFactory(sslSocketFactory,trustManager).build()</code><br>便可以完成整个Client的初始化工作。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>作为后起之秀，OkHttp对于Java原有的证书授信机制有着深入的理解，并提供了使用SSLSocketFactory的适配方法，整个API设计简洁自然，杜绝了重复的设计。当然，没有所谓的绝对安全，对于重要的证书密钥应该妥善保管，并且及时更新，避免泄露带来的连锁反应。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，遇到了一个微信支付调用Rest接口需要SSL授信的问题，遂看了一段时间自SSL证书的集成方式。&lt;/p&gt;
&lt;h3 id=&quot;Java对安全证书的支持&quot;&gt;&lt;a href=&quot;#Java对安全证书的支持&quot; class=&quot;headerlink&quot; title=&quot;Java对安全证
    
    </summary>
    
    
      <category term="OkHttp" scheme="https://www.sequarius.com/tags/OkHttp/"/>
    
      <category term="SSL" scheme="https://www.sequarius.com/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>使用MyBatisGenerator 自定义生成的XML</title>
    <link href="https://www.sequarius.com/2017/02/13/%E4%BD%BF%E7%94%A8MyBatisGenerator-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90%E7%9A%84XML/"/>
    <id>https://www.sequarius.com/2017/02/13/使用MyBatisGenerator-自定义生成的XML/</id>
    <published>2017-02-13T13:33:36.000Z</published>
    <updated>2017-02-13T13:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>根据数据库结构生成MyBatis可以使用的ORM映射文件的工具有很多，当然最著名的是MyBatis官方的项目<a href="http://www.mybatis.org/generator/" target="_blank" rel="external">MyBatis Generator</a>,该工具提供了一个可定制的ORM生成器，可以自定义生成ORM类型（XML还是基于注解）的方式，可以对表/列进行特殊定制，还可以定义数据库支持,基本主流的数据库都进行支持，项目文档也详细说明了各项配置，下面简单说几个比较常用的配置，其余细节可以参阅文档。</p>
<h4 id="generatedKey"><a href="#generatedKey" class="headerlink" title="generatedKey"></a>generatedKey</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure>
<p>该节点是<code>&lt;table&gt;</code>节点的子节点。</p>
<p>通过该项配置在生成的select语句会生成<code>keyProperty=&quot;id&quot;</code>属性，即在调用<code>insert(T t)</code>或者<code>insertSelective(T t)</code>方法后T会在插入成功后同时被设置主键，方便后续进行<code>updateByPrimeryKey(T t)</code>的操作。</p>
<h4 id="suppressDate"><a href="#suppressDate" class="headerlink" title="suppressDate"></a>suppressDate</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;commentGenerator&gt;</div><div class="line">    &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;</div><div class="line">&lt;/commentGenerator&gt;</div></pre></td></tr></table></figure>
<p>该节点是<code>&lt;context&gt;</code>的子节点，通过该项设置可以避免生成很多无用的<code>generate by MyBatis generator xxx</code>之类的注解，当然如果使用maven deploy的话有没有注释影响也不是很大。</p>
<h4 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;plugin type=&quot;gov.sequarius.mybatis.MySQLPaginationPlugin&quot;/&gt;</div></pre></td></tr></table></figure>
<p>该节点是<code>&lt;context&gt;</code> 的子节点，为生成器提供的插件支持,也是本文所介绍的重点内容，所谓插件为MyBatis Generator提供的自定义最灵活的地方，通过插件接口可以对生成的类文件、XML文件提供强大的自定义功能。</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="Plugin与PluginAdapter"><a href="#Plugin与PluginAdapter" class="headerlink" title="Plugin与PluginAdapter"></a>Plugin与PluginAdapter</h4><h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p>插件接口为<code>org.mybatis.generator.api.Plugin</code>当然这是一个最上层的接口，在同层包下提供了<code>org.mybatis.generator.api.PluginAdapter</code>一个适配器，可以看到官方的一些插件（位于<code>org.mybatis。
.generator.plugins</code>包下）基本都继承自这个抽象类，我们这里主要研究的对象也是<code>PluginAdapter</code>。</p>
<h5 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h5><p>首先看下基本方法，对于<code>Plugin</code>的各类方法，<code>PluginAdapter</code>都进行了基础实现，抽象的方法仅仅只有<code>boolean validate(List&lt;String&gt; warnings)</code>一个，看名字可以猜出这是一个校验方法，用于传入warnnings来检查是否插件可用。</p>
<h5 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h5><p>由于方法众多，故只寻找有代表的两个讲下，更多细节可以参考官方文档。</p>
<p><code>sqlMap???ElementGenerated(XmlElement element, IntrospectedTable introspectedTable)</code> 该方法在基础XML生成后调用，可以看到入参有XmlElement，拿到XmlElement后就可以操作生成的XML了。</p>
<p><code>modelExampleClassGenerated(TopLevelClass, IntrospectedTable)</code>该方法在生成modelExample时调用，如果要修改生成的modelExample内容，可以使用TopLevelClass进行反射操作。</p>
<p>剩下的方法基本根据命名规则都可以猜到是干什么，对于类和XML的函数参数都是一样的，只要有参数，就可以进行定制。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="使生成的查询列表方法支持分页"><a href="#使生成的查询列表方法支持分页" class="headerlink" title="使生成的查询列表方法支持分页"></a>使生成的查询列表方法支持分页</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class PagePlug extends PluginAdapter &#123;</div><div class="line">@Override</div><div class="line">    public boolean modelExampleClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable)</div><div class="line">    &#123;</div><div class="line">        String pageEntityName=&quot;page&quot;;</div><div class="line">        topLevelClass.addImportedType(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;));</div><div class="line">        CommentGenerator commentGenerator = context.getCommentGenerator();</div><div class="line">        Field field = new Field();</div><div class="line">        field.setVisibility(JavaVisibility.PROTECTED);</div><div class="line">        field.setType(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;));</div><div class="line">        field.setName(pageEntityName);</div><div class="line">        commentGenerator.addFieldComment(field, introspectedTable);</div><div class="line">        topLevelClass.addField(field);</div><div class="line">        char c = pageEntityName.charAt(0);</div><div class="line">        String camel = Character.toUpperCase(c) + pageEntityName.substring(1);</div><div class="line">        Method method = new Method();</div><div class="line">        method.setVisibility(JavaVisibility.PUBLIC);</div><div class="line">        method.setName(&quot;set&quot; + camel);</div><div class="line">        method.addParameter(new Parameter(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;), pageEntityName));</div><div class="line">        method.addBodyLine(&quot;this.&quot; + pageEntityName + &quot;=&quot; + pageEntityName + &quot;;&quot;);</div><div class="line">        commentGenerator.addGeneralMethodComment(method, introspectedTable);</div><div class="line">        topLevelClass.addMethod(method);</div><div class="line">        method = new Method();</div><div class="line">        method.setVisibility(JavaVisibility.PUBLIC);</div><div class="line">        method.setReturnType(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;));</div><div class="line">        method.setName(&quot;get&quot; + camel);</div><div class="line">        method.addBodyLine(&quot;return &quot; + pageEntityName + &quot;;&quot;);</div><div class="line">        commentGenerator.addGeneralMethodComment(method, introspectedTable);</div><div class="line">        topLevelClass.addMethod(method);</div><div class="line">        return super.modelExampleClassGenerated(topLevelClass, introspectedTable);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public boolean sqlMapSelectByExampleWithoutBLOBsElementGenerated(XmlElement element, IntrospectedTable introspectedTable)</div><div class="line">    &#123;</div><div class="line">        XmlElement page = new XmlElement(&quot;if&quot;);</div><div class="line">        page.addAttribute(new Attribute(&quot;test&quot;, &quot;page != null&quot;));</div><div class="line">        page.addElement(new TextElement(&quot;limit #&#123;page.begin&#125; , #&#123;page.length&#125;&quot;));</div><div class="line">        element.addElement(page);</div><div class="line">        return super.sqlMapUpdateByExampleWithoutBLOBsElementGenerated(element, introspectedTable);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean validate(List&lt;String&gt; warnings)</div><div class="line">    &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="create-time和update-time不在update时候更新"><a href="#create-time和update-time不在update时候更新" class="headerlink" title="create_time和update_time不在update时候更新"></a>create_time和update_time不在update时候更新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">public class IgnoreFieldPlug extends PluginAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public boolean sqlMapUpdateByExampleSelectiveElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123;</div><div class="line">        removeTimeAttribute(element);</div><div class="line">        return super.sqlMapUpdateByExampleSelectiveElementGenerated(element, introspectedTable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean sqlMapUpdateByPrimaryKeySelectiveElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123;</div><div class="line">        removeTimeAttribute(element);</div><div class="line">        return super.sqlMapUpdateByPrimaryKeySelectiveElementGenerated(element, introspectedTable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean sqlMapUpdateByExampleWithoutBLOBsElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123;</div><div class="line">//        removeTimeTextAttribute(element);</div><div class="line">        removeTimeTextAttribute(element);</div><div class="line">        return super.sqlMapUpdateByExampleWithoutBLOBsElementGenerated(element, introspectedTable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean sqlMapUpdateByPrimaryKeyWithoutBLOBsElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123;</div><div class="line">        removeTimeTextAttribute(element);</div><div class="line">        return super.sqlMapUpdateByPrimaryKeyWithoutBLOBsElementGenerated(element, introspectedTable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void removeTimeTextAttribute(XmlElement element) &#123;</div><div class="line">        List&lt;Element&gt; elements = element.getElements();</div><div class="line">        int removeCommaIndex=0;</div><div class="line">        TextElement replaceElement=null;</div><div class="line">        Iterator&lt;Element&gt; iterator = elements.iterator();</div><div class="line">        while (iterator.hasNext())&#123;</div><div class="line">            Element baseElements=elements.get(i);</div><div class="line">            if (baseElements instanceof TextElement)&#123;</div><div class="line">                TextElement targetElment=(TextElement)baseElements;</div><div class="line">                if(targetElment.getContent().contains(&quot;update_time&quot;)||targetElment.getContent().contains(&quot;create_time&quot;))&#123;</div><div class="line">                    iterator.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (baseElements instanceof TextElement)&#123;</div><div class="line">                TextElement targetElment=(TextElement)baseElements;</div><div class="line">                if(targetElment.getContent().contains(&quot;where&quot;))&#123;</div><div class="line">                    removeCommaIndex=i-1;</div><div class="line">                    replaceElement=(TextElement)(elements.get(removeCommaIndex));</div><div class="line">                    String content = replaceElement.getContent().trim();</div><div class="line">                    replaceElement=new TextElement(content.substring(0,content.length()-1));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            iterator.next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public boolean validate(List&lt;String&gt; warnings)</div><div class="line">    &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    private void removeTimeAttribute(XmlElement element) &#123;</div><div class="line">        List&lt;Element&gt; elements = element.getElements();</div><div class="line">        Iterator&lt;Element&gt; iterator = elements.iterator();</div><div class="line">        while (iterator.hasNext())&#123;</div><div class="line">            Element baseElements=elements.get(i);</div><div class="line">            if (!(baseElements instanceof XmlElement))&#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            XmlElement targetElment=(XmlElement)baseElements;</div><div class="line">            if(targetElment.getName().contains(&quot;set&quot;))&#123;</div><div class="line">                List&lt;Element&gt; innerElements = targetElment.getElements();</div><div class="line">                for (int i1 = 0; i1 &lt; innerElements.size(); i1++) &#123;</div><div class="line">                    Element baseInnerElements=elements.get(i);</div><div class="line">                    if (!(baseInnerElements instanceof XmlElement))&#123;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                    targetElment=(XmlElement)innerElements.get(i1);</div><div class="line">                    Iterator&lt;Attribute&gt; attributeIterator = targetElment.getAttributes().iterator();</div><div class="line">                    while (attributeIterator.hasNext())&#123;</div><div class="line">                        attributeIterator.remove();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;根据数据库结构生成MyBatis可以使用的ORM映射文件的工具有很多，当然最著名的是MyBatis官方的项目&lt;a href=&quot;http://
    
    </summary>
    
    
      <category term="使用MyBatisGenerator" scheme="https://www.sequarius.com/tags/%E4%BD%BF%E7%94%A8MyBatisGenerator/"/>
    
      <category term="自定义生成的XML" scheme="https://www.sequarius.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%9F%E6%88%90%E7%9A%84XML/"/>
    
  </entry>
  
  <entry>
    <title>基于Redis的计划任务实现</title>
    <link href="https://www.sequarius.com/2016/09/19/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.sequarius.com/2016/09/19/基于Redis的定时任务实现/</id>
    <published>2016-09-19T13:50:14.000Z</published>
    <updated>2017-02-12T14:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>常有一些使用场景，比如操作远程服务失败，需要在指定时间后重试。业务方面，比如有订单在X分钟后没有完成操作则变更状态等需求，这里使用RedisTemplete，利用<code>expired</code>消息实现了一个基于Redis在指时间后进行操作的服务实现。</p>
<h3 id="redis-远程访问"><a href="#redis-远程访问" class="headerlink" title="redis 远程访问"></a>redis 远程访问</h3><p><code>redis-cli -h {redis_host} -p {redis_port}</code><br>配置<br>修改Redis配置文件/etc/redis/redis.conf，找到bind那行配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bind 127.0.0.1</div><div class="line"></div><div class="line">bind 0.0.0.0</div></pre></td></tr></table></figure></p>
<p>指定配置文件然后重启Redis服务即可：</p>
<p><code>$ sudo redis-server /etc/redis/redis.conf</code></p>
<h3 id="键空间通知"><a href="#键空间通知" class="headerlink" title="键空间通知"></a>键空间通知</h3><p>这里需要配置 notify-keyspace-events 的参数为 “Ex”。x 代表了过期事件。 <code>notify-keyspace-events &quot;Ex&quot;</code></p>
<p>添加键值事件订阅<br><code>127.0.0.1:6379&gt; psubscribe __keyevent@0__:expired</code></p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>定义一个TimeKey表示该字段已重试的次数，在开始尝试重试操作的时候校验重试次数是否达到上限，并确定下次重试时间，目前实现是以<code>1s,10s,1min,10min,1h,3h,6h</code>的间隔重试。</li>
<li>定义一个EntityKey表示该重试传入的实体，这里使用了Json序列化实体，当然也可以用其他的方法序列化，可以通过<code>RedisSerializer&lt;T&gt;</code>接口实现序列化与反序列化过程，并在使用<code>RedisTemplete</code>或者初始化时候<code>setKeySerializer(RedisSerializer&lt;?&gt; serializer)</code>和<code>setValueSerializer(RedisSerializer&lt;?&gt; serializer)</code></li>
<li>定义一个NotifyKey表示订阅过期事件的key，当接受到该key过期事件的时候，检索EntityKey并分发到指定的RetryImplement。</li>
</ul>
<h3 id="配置redisconfig"><a href="#配置redisconfig" class="headerlink" title="配置redisconfig"></a>配置redisconfig</h3><p>要监听过期事件，需要配置RedisMessageListenerContainer<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import lombok.extern.slf4j.Slf4j;</div><div class="line">import org.springframework.context.annotation.Bean;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</div><div class="line">import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</div><div class="line">import org.springframework.data.redis.core.RedisTemplate;</div><div class="line">import org.springframework.data.redis.listener.ChannelTopic;</div><div class="line">import org.springframework.data.redis.listener.RedisMessageListenerContainer;</div><div class="line">import org.springframework.data.redis.listener.Topic;</div><div class="line">import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</div><div class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</div><div class="line"></div><div class="line">import javax.annotation.Resource;</div><div class="line">import java.util.HashSet;</div><div class="line">import java.util.Set;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Sequarius on 2016/9/7.</div><div class="line"> */</div><div class="line">@Configuration</div><div class="line">public class RedisConfig &#123;</div><div class="line">    @Resource</div><div class="line">    private JedisConnectionFactory jedisConnectionFactory;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private ExpiresMessageController expiresMessageController;</div><div class="line"></div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public StringRedisSerializer stringRedisSerializer()&#123;</div><div class="line">        return new StringRedisSerializer();</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer()&#123;</div><div class="line">        return new GenericJackson2JsonRedisSerializer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public RedisMessageListenerContainer redisMessageListenerContainer() &#123;</div><div class="line">        RedisMessageListenerContainer container = new RedisMessageListenerContainer();</div><div class="line">        container.setConnectionFactory(jedisConnectionFactory);</div><div class="line">        container.setConnectionFactory(jedisConnectionFactory);</div><div class="line">        Set&lt;Topic&gt; topics = new HashSet&lt;Topic&gt;() &#123;&#123;</div><div class="line">            add(new ChannelTopic(&quot;__keyevent@0__:expired&quot;));</div><div class="line">        &#125;&#125;;</div><div class="line">        container.addMessageListener(expiresMessageController, topics);</div><div class="line">        return container;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public RedisTemplate redisTemplate(RedisConnectionFactory connectionFactory,</div><div class="line">                                       StringRedisSerializer serializer,</div><div class="line">                                       GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer</div><div class="line">                                       ) &#123;</div><div class="line">        RedisTemplate template = new RedisTemplate();</div><div class="line">        template.setConnectionFactory(connectionFactory);</div><div class="line">        template.setKeySerializer(serializer);</div><div class="line">        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());</div><div class="line">        return template;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现MessageListener接口"><a href="#实现MessageListener接口" class="headerlink" title="实现MessageListener接口"></a>实现MessageListener接口</h3><p>MessageListener是接受message的一个回调接口，在<code>public void onMessage(Message message, byte[] bytes)</code>中回调接收到的消息，message有两个属性，一个是’byte[]’的MessageBody,一个也是<code>byte[]</code>的MessageChannel,该属性表示该message发生的时间频段，在这个项目下为<code>&quot;__keyevent@0__:expired&quot;</code>，即为0号库的过期事件。</p>
<p>这里使用了类名+Tag的方式标注一个unique的重试实体，在分发过程中检索对应的<code>RetryListener</code>初始化传入的类名进行消息分发。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import lombok.extern.slf4j.Slf4j;</div><div class="line">import org.springframework.data.redis.connection.Message;</div><div class="line">import org.springframework.data.redis.connection.MessageListener;</div><div class="line">import org.springframework.data.redis.core.RedisTemplate;</div><div class="line">import org.springframework.data.redis.core.StringRedisTemplate;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">import javax.annotation.PostConstruct;</div><div class="line">import javax.annotation.Resource;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Sequarius on 2016/9/7.</div><div class="line"> */</div><div class="line">@Component</div><div class="line">public class ExpiresMessageController implements MessageListener &#123;</div><div class="line">    @Resource</div><div class="line">    private RedisTemplate redisTemplate;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private StringRedisTemplate stringRedisTemplate;</div><div class="line"></div><div class="line">    private Map&lt;String, SubMessageListener&gt; subMessageListeners;</div><div class="line"></div><div class="line">    @PostConstruct</div><div class="line">    void init() &#123;</div><div class="line">        subMessageListeners = new HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onMessage(Message message, byte[] bytes) &#123;</div><div class="line">        byte[] bodyBytes = message.getBody();</div><div class="line"></div><div class="line">        String notifyKey = (String) stringRedisTemplate.getValueSerializer().deserialize(bodyBytes);</div><div class="line"></div><div class="line">        //no subscribe for us</div><div class="line">        if (!notifyKey.startsWith(Constant.PREFIX_PAYMENT_KEY)) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        String subScribeObjName = notifyKey.replaceAll(Constant.PREFIX_PAYMENT_KEY, &quot;&quot;);</div><div class="line">//        Object o = redisTemplate.opsForValue().get(Constant.PREFIX_PAYMENT_ENTITY_KEY + subScribeObjName);</div><div class="line">        String[] objInfo = subScribeObjName.split(&quot;:&quot;);</div><div class="line">        String className = objInfo[0];</div><div class="line">        String tag=objInfo[1];</div><div class="line">        log.debug(&quot;getmessage==&#123;&#125;&quot;, notifyKey);</div><div class="line">        log.debug(&quot;className==&#123;&#125;&quot;, className);</div><div class="line">        try &#123;</div><div class="line">            Class target=Class.forName(className);</div><div class="line">            redisTemplate.setValueSerializer(new FastJsonSerializer&lt;&gt;(target));</div><div class="line">            Object o = redisTemplate.opsForValue().get(Constant.PREFIX_PAYMENT_ENTITY_KEY + subScribeObjName);</div><div class="line">            subMessageListeners.get(className).onMessage(o,tag);</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public &lt;E,T&gt; void addSubMessageListener(Class&lt;?&gt; clazz, SubMessageListener&lt;E,T&gt; subMessageListener) &#123;</div><div class="line">        log.debug(&quot;puted:&#123;&#125;&quot;,clazz.getName());</div><div class="line">        subMessageListeners.put(clazz.getName(), subMessageListener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现序列化接口"><a href="#实现序列化接口" class="headerlink" title="实现序列化接口"></a>实现序列化接口</h3><p>由于项目使用的FastJson，就用FastJson实现了一个简单的序列化与反序列化，当然在初始化传入了class，以便在反序列化时使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.alibaba.fastjson.JSON;</div><div class="line">import com.alibaba.fastjson.serializer.SerializerFeature;</div><div class="line">import lombok.extern.slf4j.Slf4j;</div><div class="line">import org.springframework.data.redis.serializer.RedisSerializer;</div><div class="line">import org.springframework.data.redis.serializer.SerializationException;</div><div class="line"></div><div class="line">import java.nio.charset.Charset;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Sequarius on 2016/9/8.</div><div class="line"> */</div><div class="line">@Slf4j</div><div class="line">public class FastJsonSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; &#123;</div><div class="line">    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);</div><div class="line"></div><div class="line">    private Class&lt;T&gt; targetClass;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public byte[] serialize(T t) throws SerializationException &#123;</div><div class="line">        if (t == null) &#123;</div><div class="line">            return new byte[0];</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            return JSON.toJSONString(t, SerializerFeature.WriteClassName)</div><div class="line">                    .getBytes(DEFAULT_CHARSET);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.debug(e.getMessage(), e);</div><div class="line">            return new byte[0];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public FastJsonSerializer(Class&lt;T&gt; targetClass) &#123;</div><div class="line">        this.targetClass = targetClass;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public T deserialize(byte[] bytes) throws SerializationException &#123;</div><div class="line">        if (bytes == null || bytes.length &lt;= 0) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        String jsonStr = new String(bytes, DEFAULT_CHARSET);</div><div class="line">        try &#123;</div><div class="line">            return JSON.parseObject(jsonStr, targetClass);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.debug(e.getMessage(), e);</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SubMessageListener"><a href="#SubMessageListener" class="headerlink" title="SubMessageListener"></a>SubMessageListener</h3><p>自定义的一个消息分发，分发给指定的订阅任务，而避免了全局的广播<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface SubMessageListener&lt;E,T&gt; &#123;</div><div class="line">    void onMessage(E entity,T tag);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="BaseRetry"><a href="#BaseRetry" class="headerlink" title="BaseRetry"></a>BaseRetry<e,t></e,t></h3><p>定义了一个基础的retry方法，提供了尝试重试等基础方法的实现，实现类自需要定义<code>setMessageListener()</code>并在初始化后调用便可以接收到指定Entity的消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import lombok.extern.slf4j.Slf4j;</div><div class="line">import org.springframework.data.redis.core.RedisTemplate;</div><div class="line">import org.springframework.data.redis.core.StringRedisTemplate;</div><div class="line"></div><div class="line">import javax.annotation.Resource;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Sequarius on 2016/9/7.</div><div class="line"> */</div><div class="line">@Slf4j</div><div class="line">public abstract class BaseRetry&lt;E, T&gt; &#123;</div><div class="line">    @Resource</div><div class="line">    private ExpiresMessageController expiresMessageController;</div><div class="line">    @Resource</div><div class="line">    private RedisTemplate redisTemplate;</div><div class="line">    @Resource</div><div class="line">    private StringRedisTemplate stringRedisTemplate;</div><div class="line"></div><div class="line">    public Class&lt;E&gt; clazz;</div><div class="line">    // 重试尝试间隔为1s,10s,1min,10min,1h,3h,6h一次递增</div><div class="line">    private final List&lt;Long&gt; RETRY_TABLE = new ArrayList&lt;Long&gt;() &#123;</div><div class="line">        &#123;</div><div class="line">            add(0L);</div><div class="line">            add(1L);</div><div class="line">            add(10L);</div><div class="line">            add(60L);</div><div class="line">            add(10 * 60L);</div><div class="line">            add(60 * 60L);</div><div class="line">            add(3 * 60 * 60L);</div><div class="line">            add(6 * 60 * 60L);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public BaseRetry(Class&lt;E&gt; clazz) &#123;</div><div class="line">        this.clazz = clazz;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void retry(E entity, T tag) &#123;</div><div class="line">        RetryEntity retryEntity = new RetryEntity(entity, tag).invoke();</div><div class="line">        String timeKey = retryEntity.getTimeKey();</div><div class="line">        String entryKey = retryEntity.getEntryKey();</div><div class="line">        StringBuffer entityTag = retryEntity.getEntityTag();</div><div class="line">        String memoryValue = stringRedisTemplate.opsForValue().get(timeKey);</div><div class="line"></div><div class="line">        int lastRetryTime = (memoryValue == null) ? 0 : Integer.valueOf(memoryValue);</div><div class="line">        //first Retry save entity</div><div class="line">        if (lastRetryTime == 0) &#123;</div><div class="line">            redisTemplate.setDefaultSerializer(new FastJsonSerializer&lt;&gt;(clazz));</div><div class="line">            redisTemplate.opsForValue().set(entryKey, entity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //max Retry delete entity</div><div class="line">        if (lastRetryTime &gt;= RETRY_TABLE.size() - 1) &#123;</div><div class="line">            log.warn(&quot;retry in max times entityTag==&#123;&#125;&quot;, entityTag.toString());</div><div class="line">            log.warn(&quot;retry entity==&#123;&#125;&quot;,stringRedisTemplate.opsForValue().get(entryKey));</div><div class="line">            redisTemplate.delete(entryKey);</div><div class="line">            stringRedisTemplate.delete(timeKey);</div><div class="line">            throw new RetryTimeOutOfRangeException();</div><div class="line">        &#125;</div><div class="line">        log.debug(&quot;time key=&#123;&#125;;entrykey=&#123;&#125;;lastRetryTime=&#123;&#125;&quot;, timeKey, entryKey, lastRetryTime);</div><div class="line">        //add 1 times</div><div class="line">        stringRedisTemplate.opsForValue().increment(timeKey, 1);</div><div class="line"></div><div class="line">        stringRedisTemplate.opsForValue().set(entityTag.insert(0, Constant.PREFIX_PAYMENT_KEY).toString(),</div><div class="line">                &quot;notify_key&quot;, RETRY_TABLE.get(lastRetryTime + 1), TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">//</div><div class="line"></div><div class="line">    protected void addListenner(Class&lt;?&gt; clazz, SubMessageListener listener) &#123;</div><div class="line">        expiresMessageController.addSubMessageListener(clazz, listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract void setMessageListener();</div><div class="line">    public void retrySuccess(E entity, T tag)&#123;</div><div class="line">        RetryEntity retryEntity = new RetryEntity(entity, tag).invoke();</div><div class="line">        redisTemplate.delete(retryEntity.getTimeKey());</div><div class="line">        redisTemplate.delete(retryEntity.getEntryKey());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class RetryEntity &#123;</div><div class="line">        private E entity;</div><div class="line">        private T tag;</div><div class="line">        private StringBuffer entityTag;</div><div class="line">        private String timeKey;</div><div class="line">        private String entryKey;</div><div class="line"></div><div class="line">        public RetryEntity(E entity, T tag) &#123;</div><div class="line">            this.entity = entity;</div><div class="line">            this.tag = tag;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public StringBuffer getEntityTag() &#123;</div><div class="line">            return entityTag;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public String getTimeKey() &#123;</div><div class="line">            return timeKey;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public String getEntryKey() &#123;</div><div class="line">            return entryKey;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public RetryEntity invoke() &#123;</div><div class="line">            entityTag = new StringBuffer(entity.getClass().getName())</div><div class="line">                    .append(&quot;:&quot;).append(tag.toString());</div><div class="line">            //retry times key</div><div class="line">            timeKey = new StringBuffer(Constant.PREFIX_PAYMENT_TIME_KEY).append(entityTag).toString();</div><div class="line">            //retry entity key</div><div class="line">            entryKey = new StringBuffer(Constant.PREFIX_PAYMENT_ENTITY_KEY).append(entityTag).toString();</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一个简单的http失败重试示例"><a href="#一个简单的http失败重试示例" class="headerlink" title="一个简单的http失败重试示例"></a>一个简单的http失败重试示例</h3><p>为了简单起见，这里使用了String作为Entity，通常建议使用自定义bean作为Entity<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import lombok.extern.slf4j.Slf4j;</div><div class="line">import okhttp3.OkHttpClient;</div><div class="line">import okhttp3.Request;</div><div class="line">import okhttp3.Response;</div><div class="line">import org.springframework.http.HttpStatus;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">import javax.annotation.PostConstruct;</div><div class="line">import javax.annotation.Resource;</div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by Sequarius on 2016/9/12.</div><div class="line"> */</div><div class="line">@Component</div><div class="line">@Slf4j</div><div class="line">public class HttpGetRequestRetry extends BaseRetry&lt;String, String&gt; &#123;</div><div class="line">    @Resource</div><div class="line">    OkHttpClient okHttpClient;</div><div class="line"></div><div class="line"></div><div class="line">    public HttpGetRequestRetry() &#123;</div><div class="line">        super(String.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    @PostConstruct</div><div class="line">    public void setMessageListener() &#123;</div><div class="line">        addListenner(String.class, new SubMessageListener&lt;String, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onMessage(String url, String tag) &#123;</div><div class="line">                makeRequest(url, tag);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void makeRequest(String url, String tag) &#123;</div><div class="line">        Request request = new Request.Builder().url(url).get().build();</div><div class="line">        try &#123;</div><div class="line">            Response response = okHttpClient.newCall(request).execute();</div><div class="line">            String body = response.body().string();</div><div class="line">            int responseCode = response.code();</div><div class="line">            if (responseCode != HttpStatus.OK.value() || !body.equals(&quot;SUCCESS&quot;)) &#123;</div><div class="line">                log.warn(&quot;call back url=&#123;&#125; ,response code=&#123;&#125;,body=&#123;&#125;,fail, try again &quot;, url, responseCode, body);</div><div class="line">                this.retry(url, tag);</div><div class="line">            &#125;else&#123;</div><div class="line">                log.debug(&quot;call back url=&#123;&#125; ,response code=&#123;&#125;,body=&#123;&#125;,ok &quot;, url, responseCode, body);</div><div class="line">                retrySuccess(url,tag);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            log.debug(e.getMessage(), e);</div><div class="line">            try &#123;</div><div class="line">                this.retry(url, tag);</div><div class="line">            &#125; catch (RetryTimeOutOfRangeException e1) &#123;</div><div class="line">                log.error(e1.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，对于使用<code>HttpGetRequestRetry</code>的<code>makeRequest(String url, String tag)</code>的Http请求便可以在失败时完成重试了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;常有一些使用场景，比如操作远程服务失败，需要在指定时间后重试。业务方面，比如有订单在X分钟后没有完成操作则变更状态等需求，这
    
    </summary>
    
    
      <category term="Redise" scheme="https://www.sequarius.com/tags/Redise/"/>
    
      <category term="xpired" scheme="https://www.sequarius.com/tags/xpired/"/>
    
      <category term="失败重试" scheme="https://www.sequarius.com/tags/%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95/"/>
    
      <category term="计划任务" scheme="https://www.sequarius.com/tags/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RxJava初探，一些细节</title>
    <link href="https://www.sequarius.com/2016/05/26/RxJava%E5%88%9D%E6%8E%A2-%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <id>https://www.sequarius.com/2016/05/26/RxJava初探-一些细节/</id>
    <published>2016-05-26T14:25:30.000Z</published>
    <updated>2017-01-03T05:52:18.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxJava-概述"><a href="#RxJava-概述" class="headerlink" title="RxJava 概述"></a>RxJava 概述</h1><p>a library for composing asynchronous and event-based programs using observable sequences for the Java VM”</p>
<p>一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="RxJava中观察者模式概念"><a href="#RxJava中观察者模式概念" class="headerlink" title="RxJava中观察者模式概念"></a>RxJava中观察者模式概念</h2><p>Observable-可观察者，即被观察者</p>
<p>Observer-观察者</p>
<p>subscribe-订阅事件。Observable 和 Observer 通过 subscribe() 。</p>
<h2 id="观察者-订阅者的回调事件"><a href="#观察者-订阅者的回调事件" class="headerlink" title="观察者/订阅者的回调事件"></a>观察者/订阅者的回调事件</h2><p>onNext(T t)正常的回调事件</p>
<p>onError(Throwable e) 异常发生时的回调事件</p>
<p>onCompleted() 完成时的回调事件<br><a id="more"></a></p>
<h2 id="Observable-几种常见的构造方法"><a href="#Observable-几种常见的构造方法" class="headerlink" title="Observable 几种常见的构造方法"></a>Observable 几种常见的构造方法</h2><p>create(new Observable.OnSubscribe<t>())</t></p>
<p>基础的构造方法</p>
<p>just(T…)</p>
<p>等同于onNext(t1,t2..)的调用</p>
<p>from(T[])</p>
<p>等同于<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;i.length;i++)&#123;</div><div class="line">    onNext(t[i]);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>的调用</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SmallTest</div><div class="line">   public void testRxJava() &#123;</div><div class="line">       //创建观察者</div><div class="line">       Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.d(TAG, &quot;completed&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.d(TAG, &quot;error&quot;);</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.d(TAG, &quot;get string ==&quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">       //创建订阅者 订阅者是观察者的一个实现类 封装了onStart() unsubscribe()等方法</div><div class="line">       Subscriber&lt;String&gt; stringSubscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.d(TAG, &quot;completed&quot;);</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.d(TAG, &quot;error&quot;);</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.d(TAG, &quot;get string ==&quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">       //构造被观察者</div><div class="line">       Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               subscriber.onNext(&quot;simple&quot;);</div><div class="line">               subscriber.onNext(&quot;test&quot;);</div><div class="line">               subscriber.onNext(&quot;try&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       //订阅观察者</div><div class="line">       Log.d(TAG, &quot;observer subscribing&quot;);</div><div class="line">       observable.subscribe(observer);</div><div class="line">       observable.subscribe(observer);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action1、Action2、……、ActionN 是RxJava的一系列接口，只包含一个call()方法，Subscriber可以接受这一些列参数构造，产生不完整的回调。<br>示例<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@MediumTest</div><div class="line">    public void testAction()&#123;</div><div class="line">        Action0 action=new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Action1&lt;String&gt; action1=new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.d(TAG,&quot;action1 get == &quot;+ s);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Observable&lt;String&gt; observable=Observable.just(&quot;foo&quot;,&quot;bar&quot;,&quot;fooo&quot;,&quot;baar&quot;);</div><div class="line">        observable.subscribe(action1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>此外，还有三种方法重载<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError)</div><div class="line">public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted)</div></pre></td></tr></table></figure></p>
<p>分别为支持onError、onComplted()的构造方式，可以看出,第二个方法和new Subscriber()已经并无区别了</p>
<h2 id="Func"><a href="#Func" class="headerlink" title="Func"></a>Func</h2><p>如同Action,Func1,Func2,…,FuncN为Rx提供的变换函数，所谓变换就是处理加工数据的过程，如把传入的URI转换成response或是将传入的资源转换为Bitmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5, T t6)</div></pre></td></tr></table></figure>
<p>为Observable设置Fuc的方法，一个具体的示例如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@MediumTest</div><div class="line">public void testFunc() &#123;</div><div class="line">    Observable.just(45, 48, 78, 147, 88, 488)</div><div class="line">            .map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public String call(Integer integer) &#123;</div><div class="line">                    return String.valueOf(integer);</div><div class="line">                &#125;</div><div class="line">            &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void call(String s) &#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外，还有<code>public final &lt;R&gt; Observable&lt;R&gt; flatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func)</code>这个方法来设置将T 转换为R[]的一转多方法。</p>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler "></a>Scheduler </h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Scheduler为RxJava的线程调度起，指定任务执行的线程</p>
<p>几个内置的Scheduler</p>
<ul>
<li>Schedulers.immediate():不指定运行线程直接在当前线程运行，默认设置。</li>
<li>Schedulers.newThread(): 在新线程执行操作。</li>
<li>Schedulers .io(): I/O 线程，I/O操作所使用的 Scheduler。 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。</li>
<li>Schedulers.computation(): 计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，使用大小为CUP核心数的的线程池。</li>
<li>AndroidSchedulers.mainThread()：在Android 主线程即UI线程运行。</li>
</ul>
<h2 id="几个重要函数"><a href="#几个重要函数" class="headerlink" title="几个重要函数"></a>几个重要函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public final Observable&lt;T&gt; observeOn(Scheduler scheduler)</div><div class="line">public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler)</div></pre></td></tr></table></figure>
<p>分别为指定被观察者call()方法发生线程和订阅者事件回调线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RxJava-概述&quot;&gt;&lt;a href=&quot;#RxJava-概述&quot; class=&quot;headerlink&quot; title=&quot;RxJava 概述&quot;&gt;&lt;/a&gt;RxJava 概述&lt;/h1&gt;&lt;p&gt;a library for composing asynchronous and event-based programs using observable sequences for the Java VM”&lt;/p&gt;
&lt;p&gt;一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;RxJava中观察者模式概念&quot;&gt;&lt;a href=&quot;#RxJava中观察者模式概念&quot; class=&quot;headerlink&quot; title=&quot;RxJava中观察者模式概念&quot;&gt;&lt;/a&gt;RxJava中观察者模式概念&lt;/h2&gt;&lt;p&gt;Observable-可观察者，即被观察者&lt;/p&gt;
&lt;p&gt;Observer-观察者&lt;/p&gt;
&lt;p&gt;subscribe-订阅事件。Observable 和 Observer 通过 subscribe() 。&lt;/p&gt;
&lt;h2 id=&quot;观察者-订阅者的回调事件&quot;&gt;&lt;a href=&quot;#观察者-订阅者的回调事件&quot; class=&quot;headerlink&quot; title=&quot;观察者/订阅者的回调事件&quot;&gt;&lt;/a&gt;观察者/订阅者的回调事件&lt;/h2&gt;&lt;p&gt;onNext(T t)正常的回调事件&lt;/p&gt;
&lt;p&gt;onError(Throwable e) 异常发生时的回调事件&lt;/p&gt;
&lt;p&gt;onCompleted() 完成时的回调事件&lt;br&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="https://www.sequarius.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>一键评教是怎么通过OkHttp实现的</title>
    <link href="https://www.sequarius.com/2016/05/12/%E4%B8%80%E9%94%AE%E8%AF%84%E6%95%99%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87Java%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <id>https://www.sequarius.com/2016/05/12/一键评教是怎么通过Java实现的/</id>
    <published>2016-05-12T14:30:12.000Z</published>
    <updated>2017-01-03T05:52:18.797Z</updated>
    
    <content type="html"><![CDATA[<p>最近很多人问一键评教的一些细节，所以写一点在Java做爬虫程序的一些技术点。首先，什么是评教？教务系统神来之笔了一个评教系统，每门课程有大约6、7个评论选项，还要写评论，每学期课程大概有10门，最奇葩的是，如果没有完成评教请求其他的服务还会被自动拦截到评教页面，这也意味着完成这项工作耗费时间，至于对教学有没有实际作用就只有仁者见仁了。<br>所以，在最新一版加入了自动评教功能。这篇主要说下通过OkHttp爬虫的一些细节。</p>
<h2 id="如何保存保存Session？"><a href="#如何保存保存Session？" class="headerlink" title="如何保存保存Session？"></a>如何保存保存Session？</h2><p>对于如何保存页面状态获取需要Session认证的方法，可以使用OkHttp的拦截器，当然，OKHttp提供了一个 CookieJar 的接口可以方便完成这个任务，这里示例是一个没有做持久化存储Cookie的示例。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class EPCookieJar implements CookieJar &#123;</div><div class="line"></div><div class="line">    private final HashMap&lt;String, List&lt;Cookie&gt;&gt; cookieStore = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void saveFromResponse(HttpUrl httpUrl, List&lt;Cookie&gt; list) &#123;</div><div class="line">        cookieStore.put(httpUrl.host(), list);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;Cookie&gt; loadForRequest(HttpUrl httpUrl) &#123;</div><div class="line">        List&lt;Cookie&gt; cookies = cookieStore.get(httpUrl.host());</div><div class="line">        return cookies != null ? cookies : new ArrayList&lt;Cookie&gt;();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h2><p>在构建请求Builder的时候设置实现的CookieJar<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public OKHttpJar login(String username, String password) &#123;</div><div class="line">        OKHttpJar OKHttpJar = new OKHttpJar();</div><div class="line">        OkHttpClient client = new OkHttpClient.Builder().cookieJar(new EPCookieJar()).build();</div><div class="line">        OKHttpJar.setClient(client);</div><div class="line">        String sign = String.valueOf(System.currentTimeMillis());</div><div class="line">        FormBody formBody = new FormBody.Builder().add(&quot;Action&quot;, &quot;Login&quot;)</div><div class="line">                .add(&quot;userName&quot;, username)</div><div class="line">                .add(&quot;pwd&quot;, CommonUtils.getMD5String((username + sign + CommonUtils.getMD5String(password.trim()))))</div><div class="line">                .add(&quot;sign&quot;, sign).build();</div><div class="line">        Request request = new Request.Builder().url(Constant.AAO_HOST + &quot;/Common/Handler/UserLogin.ashx&quot;).post(formBody).build();</div><div class="line">        JSONObject object = new JSONObject();</div><div class="line">        OKHttpJar.setJsonObject(object);</div><div class="line">        try &#123;</div><div class="line">            Response response = client.newCall(request).execute();</div><div class="line">            Integer resultCode = Integer.valueOf(response.body().string());</div><div class="line">            OKHttpJar.setResultCode(resultCode);</div><div class="line"></div><div class="line">            switch (resultCode) &#123;</div><div class="line">                case 0:</div><div class="line">                    break;</div><div class="line">                case 2:</div><div class="line">                    object.put(&quot;result&quot;, false);</div><div class="line">                    object.put(&quot;message&quot;, &quot;账号已被封停！&quot;);</div><div class="line">                    break;</div><div class="line">                case 4:</div><div class="line">                    object.put(&quot;result&quot;, false);</div><div class="line">                    object.put(&quot;message&quot;, &quot;账号或者密码错误！&quot;);</div><div class="line">                    break;</div><div class="line">                default:</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            OKHttpJar.setResultCode(-1);</div><div class="line">            object.put(&quot;result&quot;, false);</div><div class="line">            object.put(&quot;message&quot;, &quot;server error！&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return OKHttpJar;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="解析页面"><a href="#解析页面" class="headerlink" title="解析页面"></a>解析页面</h2><p>使用Jsoup构造Document对象，然后就可以像JavaScript操作DOM内容了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> public List&lt;ClassInfo&gt; getEvaluationList(OKHttpJar OKHttpJar) &#123;</div><div class="line">        Request request = new Request.Builder().url(Constant.AAO_HOST + &quot;/TeachingEvaluation/List.aspx&quot;).get().build();</div><div class="line">        List&lt;ClassInfo&gt; classInfos = new ArrayList&lt;&gt;();</div><div class="line">        try &#123;</div><div class="line">            OkHttpClient client = OKHttpJar.getClient();</div><div class="line">            Response response = client.newCall(request).execute();</div><div class="line">            String string = response.body().string();</div><div class="line"></div><div class="line"></div><div class="line">//            System.out.println(string);</div><div class="line">            Document parse = Jsoup.parse(string);</div><div class="line">            Elements links = parse.getElementsByTag(&quot;a&quot;);</div><div class="line">            for (Element link : links) &#123;</div><div class="line">                String linkHref = link.attr(&quot;href&quot;);</div><div class="line">                if (linkHref.contains(&quot;Eval.aspx?id=&quot;)) &#123;</div><div class="line">                    classInfos.add(new ClassInfo(linkHref.replace(&quot;Eval.aspx?id=&quot;, &quot;&quot;)));</div><div class="line">                &#125;</div><div class="line">//                String linkText = link.text();</div><div class="line">            &#125;</div><div class="line">            Elements TeacherElements = parse.getElementsByAttributeValueContaining(&quot;style&quot;, &quot;width:200px;&quot;);</div><div class="line">            for (int i = 0; i &lt; TeacherElements.size(); i++) &#123;</div><div class="line">                classInfos.get(i).setTeacher(TeacherElements.get(i).text());</div><div class="line">            &#125;</div><div class="line">            Elements ClassNameElements = parse.getElementsByAttributeValueContaining(&quot;style&quot;, &quot;width: 300px;&quot;);</div><div class="line">            for (int i = 0; i &lt; ClassNameElements.size(); i++) &#123;</div><div class="line">                classInfos.get(i).setClassName(ClassNameElements.get(i).text());</div><div class="line">            &#125;</div><div class="line">            Elements statusElements = parse.getElementsByClass(&quot;btn_conn1&quot;);</div><div class="line">            for (int i = 0; i &lt; statusElements.size(); i++) &#123;</div><div class="line">                if (statusElements.get(i).text().equals(&quot;查看&quot;)) &#123;</div><div class="line">                    classInfos.get(i).setEvaluated(true);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            for (int i = 0; i &lt; classInfos.size(); i++) &#123;</div><div class="line">                classInfos.get(i).setClassId(getClassID(client, classInfos.get(i)));</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            OKHttpJar.setResultCode(-1);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return classInfos;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public String getClassID(OkHttpClient client, ClassInfo info) &#123;</div><div class="line">    Request request = new Request.Builder().url(Constant.AAO_HOST + &quot;/TeachingEvaluation/Eval.aspx?id=&quot; + info.getId()).get().build();</div><div class="line">    String reslut = null;</div><div class="line">    try &#123;</div><div class="line">        Response response = client.newCall(request).execute();</div><div class="line">        Document parse = Jsoup.parse(response.body().string());</div><div class="line">        Elements elements = parse.getElementsByAttributeValue(&quot;name&quot;, &quot;teachclassid&quot;);</div><div class="line">        for (Element element : elements) &#123;</div><div class="line">            reslut = element.attr(&quot;value&quot;);</div><div class="line">        &#125;</div><div class="line">        __VIEWSTATEGENERATOR = parse.getElementById(&quot;__VIEWSTATEGENERATOR&quot;).attr(&quot;value&quot;);</div><div class="line">        __VIEWSTATE = parse.getElementById(&quot;__VIEWSTATE&quot;).attr(&quot;value&quot;);</div><div class="line"></div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return reslut;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里就已经拿到了所有完成请求的参数信息了，剩下的就不用说了吧。这个小玩具已经被归进了<a href="https://github.com/sequarius/SequariusToys/tree/master/AAOClient" target="_blank" rel="external">SequariusToys_AAOClient</a>项目中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近很多人问一键评教的一些细节，所以写一点在Java做爬虫程序的一些技术点。首先，什么是评教？教务系统神来之笔了一个评教系统，每门课程有大约6、7个评论选项，还要写评论，每学期课程大概有10门，最奇葩的是，如果没有完成评教请求其他的服务还会被自动拦截到评教页面，这也意味着完成这项工作耗费时间，至于对教学有没有实际作用就只有仁者见仁了。&lt;br&gt;所以，在最新一版加入了自动评教功能。这篇主要说下通过OkHttp爬虫的一些细节。&lt;/p&gt;
&lt;h2 id=&quot;如何保存保存Session？&quot;&gt;&lt;a href=&quot;#如何保存保存Session？&quot; class=&quot;headerlink&quot; title=&quot;如何保存保存Session？&quot;&gt;&lt;/a&gt;如何保存保存Session？&lt;/h2&gt;&lt;p&gt;对于如何保存页面状态获取需要Session认证的方法，可以使用OkHttp的拦截器，当然，OKHttp提供了一个 CookieJar 的接口可以方便完成这个任务，这里示例是一个没有做持久化存储Cookie的示例。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public class EPCookieJar implements CookieJar &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    private final HashMap&amp;lt;String, List&amp;lt;Cookie&amp;gt;&amp;gt; cookieStore = new HashMap&amp;lt;&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    public void saveFromResponse(HttpUrl httpUrl, List&amp;lt;Cookie&amp;gt; list) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        cookieStore.put(httpUrl.host(), list);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @Override&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    public List&amp;lt;Cookie&amp;gt; loadForRequest(HttpUrl httpUrl) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        List&amp;lt;Cookie&amp;gt; cookies = cookieStore.get(httpUrl.host());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return cookies != null ? cookies : new ArrayList&amp;lt;Cookie&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OkHttp" scheme="https://www.sequarius.com/tags/OkHttp/"/>
    
      <category term="OkHttp模拟登陆" scheme="https://www.sequarius.com/tags/OkHttp%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令学习笔记-集合篇</title>
    <link href="https://www.sequarius.com/2016/05/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88%E7%AF%87/"/>
    <id>https://www.sequarius.com/2016/05/05/Redis学习笔记-集合篇/</id>
    <published>2016-05-05T13:14:50.000Z</published>
    <updated>2017-01-03T05:52:19.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash是什么？ redis的文档解释是<br>Redis hashes look exactly how one might expect a “hash” to look, with field-value pairs:<br>实际是一种散列集合结构，结构也如下：<br>{key} {domain1} {value1} {domain 2} {value2} … {domain n} {valuen}</p>
<h3 id="HMSET-key-field-value-field-value-…"><a href="#HMSET-key-field-value-field-value-…" class="headerlink" title="HMSET key field value [field value …]"></a>HMSET key field value [field value …]</h3><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。<br>此命令会覆盖哈希表中已存在的域。<br>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</p>
<h3 id="HSET-key-field-value"><a href="#HSET-key-field-value" class="headerlink" title="HSET key field value"></a>HSET key field value</h3><p>将哈希表 key 中的域 field 的值设为 value 。<br>如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。<br>如果域 field 已经存在于哈希表中，旧值将被覆盖。</p>
<h3 id="HSETNX-key-field-value"><a href="#HSETNX-key-field-value" class="headerlink" title="HSETNX key field value"></a>HSETNX key field value</h3><p>上述版本的不覆盖set版本 如果存在返回为false</p>
<h3 id="HGET-key-field"><a href="#HGET-key-field" class="headerlink" title="HGET key field"></a>HGET key field</h3><p>返回哈希表 key 中给定域 field 的值。<br><a id="more"></a></p>
<h3 id="HMGET-key-field-field-…"><a href="#HMGET-key-field-field-…" class="headerlink" title="HMGET key field [field …]"></a>HMGET key field [field …]</h3><p>返回哈希表 key 中，一个或多个给定域的值。<br>如果给定的域不存在于哈希表，那么返回一个 nil 值。<br>HSET key field value<br>将哈希表 key 中的域 field 的值设为 value 。<br>如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。<br>如果域 field 已经存在于哈希表中，旧值将被覆盖。</p>
<h3 id="HGETALL-key"><a href="#HGETALL-key" class="headerlink" title="HGETALL key"></a>HGETALL key</h3><p>返回哈希表 key 中，所有的域和值。<br>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大<br>小的两倍。</p>
<h3 id="HINCRBY-key-field-increment"><a href="#HINCRBY-key-field-increment" class="headerlink" title="HINCRBY key field increment"></a>HINCRBY key field increment</h3><p>为哈希表 key 中的域 field 的值加上增量 increment 。<br>增量也可以为负数，相当于对给定域进行减法操作。<br>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。<br>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</p>
<h3 id="HINCRBYFLOAT-key-field-increment"><a href="#HINCRBYFLOAT-key-field-increment" class="headerlink" title="HINCRBYFLOAT key field increment"></a>HINCRBYFLOAT key field increment</h3><p>上面命令的float版本</p>
<h3 id="HINCRBY、HINCRBYFLOAT"><a href="#HINCRBY、HINCRBYFLOAT" class="headerlink" title="HINCRBY、HINCRBYFLOAT"></a>HINCRBY、HINCRBYFLOAT</h3><p>上面命令的增加指定增量版本</p>
<h3 id="HLEN-key"><a href="#HLEN-key" class="headerlink" title="HLEN key"></a>HLEN key</h3><p>返回哈希表 key 中域的数量。</p>
<h3 id="HKEYS-key-HVALS-key"><a href="#HKEYS-key-HVALS-key" class="headerlink" title="HKEYS key/HVALS key"></a>HKEYS key/HVALS key</h3><p>返回哈希表 key 中的所有域/值。</p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>是一种线性的集合结构，支持常见的push/pop等操作</p>
<h3 id="LPOP-LPUSH"><a href="#LPOP-LPUSH" class="headerlink" title="LPOP/LPUSH"></a>LPOP/LPUSH</h3><p>弹入弹出</p>
<h3 id="BLPOP-BLPUSH"><a href="#BLPOP-BLPUSH" class="headerlink" title="BLPOP/BLPUSH"></a>BLPOP/BLPUSH</h3><p>阻塞版弹出/弹入原语<br>可以在最后加入超时时间</p>
<h3 id="BRPOP-BRPOP"><a href="#BRPOP-BRPOP" class="headerlink" title="BRPOP/BRPOP"></a>BRPOP/BRPOP</h3><p>弹出List尾部元素，在尾部弹入</p>
<h3 id="LINDEX-key-index"><a href="#LINDEX-key-index" class="headerlink" title="LINDEX key index"></a>LINDEX key index</h3><p>返回列表 key 中，下标为 index 的元素。<br>下标</p>
<h3 id="LINSERT-key-BEFORE-AFTER-pivot-value"><a href="#LINSERT-key-BEFORE-AFTER-pivot-value" class="headerlink" title="LINSERT key BEFORE|AFTER pivot value"></a>LINSERT key BEFORE|AFTER pivot value</h3><p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。<br>当 pivot 不存在于列表 key 时，不执行任何操作。<br>当 key 不存在时， key 被视为空列表，不执行任何操作。<br>如果 key 不是列表类型，返回一个错误。</p>
<h3 id="LRANGE-key-start-stop"><a href="#LRANGE-key-start-stop" class="headerlink" title="LRANGE key start stop"></a>LRANGE key start stop</h3><p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p>
<h3 id="LREM-key-count-value"><a href="#LREM-key-count-value" class="headerlink" title="LREM key count value"></a>LREM key count value</h3><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p>
<h3 id="LSET-key-index-value"><a href="#LSET-key-index-value" class="headerlink" title="LSET key index value"></a>LSET key index value</h3><p>将列表 key 下标为 index 的元素的值设置为 value 。<br>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p>
<h3 id="LTRIM-key-start-stop"><a href="#LTRIM-key-start-stop" class="headerlink" title="LTRIM key start stop"></a>LTRIM key start stop</h3><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的<br>元素都将被删除。</p>
<h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><p>Redis Sets are unordered collections of strings. The SADD command adds new elements to a set. It’s also possible to do a number of other operations against sets like testing if a given element already exists, performing the intersection, union or difference between multiple sets, and so forth.</p>
<h3 id="SADD-key-member-member-…"><a href="#SADD-key-member-member-…" class="headerlink" title="SADD key member [member …]"></a>SADD key member [member …]</h3><p>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽<br>略。</p>
<h3 id="SCARD-key"><a href="#SCARD-key" class="headerlink" title="SCARD key"></a>SCARD key</h3><p>集合中元素的数量。</p>
<h3 id="SDIFF-key-key-…"><a href="#SDIFF-key-key-…" class="headerlink" title="SDIFF key [key …]"></a>SDIFF key [key …]</h3><p>返回一个集合的全部成员，该集合是所有给定集合之间的差（补）集。<br>不存在的 key 被视为空集。</p>
<h3 id="SDIFFSTORE-destination-key-key-…"><a href="#SDIFFSTORE-destination-key-key-…" class="headerlink" title="SDIFFSTORE destination key [key …]"></a>SDIFFSTORE destination key [key …]</h3><p>上一个命令的保留到destination集合的版本</p>
<h3 id="SINTER-key-key-…"><a href="#SINTER-key-key-…" class="headerlink" title="SINTER key [key …]"></a>SINTER key [key …]</h3><p>返回一个集合的全部成员，该集合是所有给定集合的交集。<br>不存在的 key 被视为空集。<br>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。.</p>
<h3 id="SINTERSTORE-destination-key-key-…"><a href="#SINTERSTORE-destination-key-key-…" class="headerlink" title="SINTERSTORE destination key [key …]"></a>SINTERSTORE destination key [key …]</h3><p>上一个命令的保留到destination集合的版本</p>
<h3 id="SUNION-key-key-…"><a href="#SUNION-key-key-…" class="headerlink" title="SUNION key [key …]"></a>SUNION key [key …]</h3><p>返回一个集合的全部成员，该集合是所有给定集合的并集。<br>不存在的 key 被视为空集。</p>
<h3 id="SUNIONSTORE-destination-key-key-…"><a href="#SUNIONSTORE-destination-key-key-…" class="headerlink" title="SUNIONSTORE destination key [key …]"></a>SUNIONSTORE destination key [key …]</h3><p>上一个命令的保留到destination集合的版本</p>
<h3 id="SISMEMBER-key-member"><a href="#SISMEMBER-key-member" class="headerlink" title="SISMEMBER key member"></a>SISMEMBER key member</h3><p>判断 member 元素是否集合 key 的成员。</p>
<h3 id="SMEMBERS-key"><a href="#SMEMBERS-key" class="headerlink" title="SMEMBERS key"></a>SMEMBERS key</h3><p>返回集合 key 中的所有成员。<br>不存在的 key 被视为空集合。</p>
<h3 id="SMOVE-source-destination-member"><a href="#SMOVE-source-destination-member" class="headerlink" title="SMOVE source destination member"></a>SMOVE source destination member</h3><p>将 member 元素从 source 集合移动到 destination 集合。</p>
<h3 id="SRANDMEMBER-key-count"><a href="#SRANDMEMBER-key-count" class="headerlink" title="SRANDMEMBER key [count]"></a>SRANDMEMBER key [count]</h3><p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p>
<h3 id="SPOP-key"><a href="#SPOP-key" class="headerlink" title="SPOP key"></a>SPOP key</h3><p>移除并返回集合中的一个随机元素。<br>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用<br>SRANDMEMBER 命令。</p>
<h3 id="SREM-key-member-member-…"><a href="#SREM-key-member-member-…" class="headerlink" title="SREM key member [member …]"></a>SREM key member [member …]</h3><p>移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。<br>当 key 不是集合类型，返回一个错误。</p>
<h1 id="有序集合-SortedSet"><a href="#有序集合-SortedSet" class="headerlink" title="有序集合 SortedSet"></a>有序集合 SortedSet</h1><p>有序集合是一种带Socore的集合，可以根据score进行一些排序，查找工作。</p>
<h3 id="ZADD-key-score-member-score-member-score-member-…"><a href="#ZADD-key-score-member-score-member-score-member-…" class="headerlink" title="ZADD key score member [[score member] [score member] …]"></a>ZADD key score member [[score member] [score member] …]</h3><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新<br>插入这个 member 元素，来保证该 member 在正确的位置上。</p>
<h3 id="ZCARD-key"><a href="#ZCARD-key" class="headerlink" title="ZCARD key"></a>ZCARD key</h3><p>返回有序集 key 的基数。</p>
<h3 id="ZCOUNT-key-min-max"><a href="#ZCOUNT-key-min-max" class="headerlink" title="ZCOUNT key min max"></a>ZCOUNT key min max</h3><p>返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或<br>max )的成员的数量。</p>
<h3 id="ZINCRBY-key-increment-member"><a href="#ZINCRBY-key-increment-member" class="headerlink" title="ZINCRBY key increment member"></a>ZINCRBY key increment member</h3><p>为有序集 key 的成员 member 的 score 值加上增量 increment 。</p>
<h3 id="ZRANGE-key-start-stop-WITHSCORES"><a href="#ZRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZRANGE key start stop [WITHSCORES]"></a>ZRANGE key start stop [WITHSCORES]</h3><p>返回有序集 key 中，指定区间内的成员。<br>其中成员的位置按 score 值递增(从小到大)来排序。<br>具有相同 score 值的成员按字典序( lexicographical order )来排列。</p>
<h3 id="ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count"><a href="#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count" class="headerlink" title="ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]"></a>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</h3><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成<br>员。有序集成员按 score 值递增(从小到大)次序排列。</p>
<h3 id="ZRANK-key-member"><a href="#ZRANK-key-member" class="headerlink" title="ZRANK key member"></a>ZRANK key member</h3><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序<br>排列。</p>
<h3 id="ZREM-key-member-member-…"><a href="#ZREM-key-member-member-…" class="headerlink" title="ZREM key member [member …]"></a>ZREM key member [member …]</h3><p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。<br>当 key 存在但不是有序集类型时，返回错误。</p>
<h3 id="ZREMRANGEBYRANK-key-start-stop"><a href="#ZREMRANGEBYRANK-key-start-stop" class="headerlink" title="ZREMRANGEBYRANK key start stop"></a>ZREMRANGEBYRANK key start stop</h3><p>移除有序集 key 中，指定排名(rank)区间内的所有成员。<br>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p>
<h3 id="ZREMRANGEBYSCORE-key-min-max"><a href="#ZREMRANGEBYSCORE-key-min-max" class="headerlink" title="ZREMRANGEBYSCORE key min max"></a>ZREMRANGEBYSCORE key min max</h3><p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成<br>员。</p>
<h3 id="ZREVRANGE-key-start-stop-WITHSCORES"><a href="#ZREVRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZREVRANGE key start stop [WITHSCORES]"></a>ZREVRANGE key start stop [WITHSCORES]</h3><p>返回有序集 key 中，指定区间内的成员。<br>其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序的<br>逆序( reverse lexicographical order)排列。</p>
<h3 id="ZSCORE-key-member"><a href="#ZSCORE-key-member" class="headerlink" title="ZSCORE key member"></a>ZSCORE key member</h3><p>返回有序集 key 中，成员 member 的 score 值。<br>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p>
<h3 id="ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…"><a href="#ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…" class="headerlink" title="ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]]"></a>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]]</h3><p>[AGGREGATE SUM|MIN|MAX]<br>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并<br>将该并集(结果集)储存到 destination 。</p>
<h3 id="ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…"><a href="#ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…" class="headerlink" title="ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]]"></a>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]]</h3><p>[AGGREGATE SUM|MIN|MAX]<br>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并<br>将该交集(结果集)储存到 destination 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hash&quot;&gt;&lt;a href=&quot;#Hash&quot; class=&quot;headerlink&quot; title=&quot;Hash&quot;&gt;&lt;/a&gt;Hash&lt;/h1&gt;&lt;p&gt;Hash是什么？ redis的文档解释是&lt;br&gt;Redis hashes look exactly how one might expect a “hash” to look, with field-value pairs:&lt;br&gt;实际是一种散列集合结构，结构也如下：&lt;br&gt;{key} {domain1} {value1} {domain 2} {value2} … {domain n} {valuen}&lt;/p&gt;
&lt;h3 id=&quot;HMSET-key-field-value-field-value-…&quot;&gt;&lt;a href=&quot;#HMSET-key-field-value-field-value-…&quot; class=&quot;headerlink&quot; title=&quot;HMSET key field value [field value …]&quot;&gt;&lt;/a&gt;HMSET key field value [field value …]&lt;/h3&gt;&lt;p&gt;同时将多个 field-value (域-值)对设置到哈希表 key 中。&lt;br&gt;此命令会覆盖哈希表中已存在的域。&lt;br&gt;如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。&lt;/p&gt;
&lt;h3 id=&quot;HSET-key-field-value&quot;&gt;&lt;a href=&quot;#HSET-key-field-value&quot; class=&quot;headerlink&quot; title=&quot;HSET key field value&quot;&gt;&lt;/a&gt;HSET key field value&lt;/h3&gt;&lt;p&gt;将哈希表 key 中的域 field 的值设为 value 。&lt;br&gt;如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。&lt;br&gt;如果域 field 已经存在于哈希表中，旧值将被覆盖。&lt;/p&gt;
&lt;h3 id=&quot;HSETNX-key-field-value&quot;&gt;&lt;a href=&quot;#HSETNX-key-field-value&quot; class=&quot;headerlink&quot; title=&quot;HSETNX key field value&quot;&gt;&lt;/a&gt;HSETNX key field value&lt;/h3&gt;&lt;p&gt;上述版本的不覆盖set版本 如果存在返回为false&lt;/p&gt;
&lt;h3 id=&quot;HGET-key-field&quot;&gt;&lt;a href=&quot;#HGET-key-field&quot; class=&quot;headerlink&quot; title=&quot;HGET key field&quot;&gt;&lt;/a&gt;HGET key field&lt;/h3&gt;&lt;p&gt;返回哈希表 key 中给定域 field 的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://www.sequarius.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://www.sequarius.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令学习笔记part1:Key/String篇</title>
    <link href="https://www.sequarius.com/2016/04/28/Redis%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1-Key-String%E9%83%A8%E5%88%86/"/>
    <id>https://www.sequarius.com/2016/04/28/Redis命令学习笔记part1-Key-String部分/</id>
    <published>2016-04-28T07:13:52.000Z</published>
    <updated>2017-02-12T13:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究Redis，根据官方文档抽取了些可能会忘的命令的摘要记下来，部分是自己的理解，具体内容以<code>redis-doc</code>为准。</p>
<h3 id="SET-key-value-GET-key"><a href="#SET-key-value-GET-key" class="headerlink" title="SET key value/GET key"></a>SET key value/GET key</h3><p>存取值的通用方法</p>
<h3 id="DUMP-key"><a href="#DUMP-key" class="headerlink" title="DUMP key"></a>DUMP key</h3><p>序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为Redis 键。<br>序列化生成的值有以下几个特点：<br>1.它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。<br>2.值的编码格式和 RDB 文件保持一致。<br>3.RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</p>
<h3 id="EXPIRE-key-time"><a href="#EXPIRE-key-time" class="headerlink" title="EXPIRE key time"></a>EXPIRE key time</h3><p>1.为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。<br>2.在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。<br>3.生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。同时，对已有生存时间的key执行expire命令可以更新生存时间<br>4.所以若不过期 返回为-1 否则返回过期时间为剩余的秒时间值，可以使用ttl查询键的生存时间</p>
<h3 id="EXPIREAT-key-timestamp"><a href="#EXPIREAT-key-timestamp" class="headerlink" title="EXPIREAT key timestamp"></a>EXPIREAT key timestamp</h3><p>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。<br>不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。<br>如果生存时间设置成功，返回 1 。当 key 不存在或没办法设置生存时间，返回 0 。<br><a id="more"></a></p>
<h3 id="MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE"><a href="#MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE" class="headerlink" title="MIGRATE host port key destination-db timeout [COPY] [REPLACE]"></a>MIGRATE host port key destination-db timeout [COPY] [REPLACE]</h3><p>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。<br>原理还是使用DUMP、RESTORE进行序列化和反序列化<br>由于这是一个原子操作，所以是阻塞执行。</p>
<h3 id="MOVE-key-db"><a href="#MOVE-key-db" class="headerlink" title="MOVE key db"></a>MOVE key db</h3><p>将当前数据库的 key 移动到给定的数据库 db 当中<br>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果</p>
<h3 id="OBJECT"><a href="#OBJECT" class="headerlink" title="OBJECT"></a>OBJECT</h3><p>OBJECT 命令允许从内部察看给定 key 的 Redis 对象。<br>-REFCOUNT 引用数目<br>-IDLETIME 空闲时间<br>-ENCODING 编码方式</p>
<h3 id="PERSIST-key"><a href="#PERSIST-key" class="headerlink" title="PERSIST key"></a>PERSIST key</h3><p>移除指定key的TTL，让它获得永生。</p>
<h3 id="PEXPIRE-key"><a href="#PEXPIRE-key" class="headerlink" title="PEXPIRE key"></a>PEXPIRE key</h3><p>与EXPIRE相同作用相同，只是以毫秒为时间单位</p>
<h3 id="PEXPIREAT-key"><a href="#PEXPIREAT-key" class="headerlink" title="PEXPIREAT key"></a>PEXPIREAT key</h3><p>同PEXPIRE与EXPIRE的关系</p>
<h3 id="PTTL-key"><a href="#PTTL-key" class="headerlink" title="PTTL key"></a>PTTL key</h3><p>TTL的毫秒版</p>
<h3 id="RANDOMKEY"><a href="#RANDOMKEY" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h3><p>随机返回一个key，数据库为空时返回nil，抽奖程序知道怎么写了才不会被喷了吧？</p>
<h3 id="RENAME-key-newkey"><a href="#RENAME-key-newkey" class="headerlink" title="RENAME key newkey"></a>RENAME key newkey</h3><p>改名，<br>1.当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。<br>2.当 newkey 已经存在时， RENAME 命令将覆盖旧值。</p>
<h3 id="RENAMENX-key-new-key"><a href="#RENAMENX-key-new-key" class="headerlink" title="RENAMENX key new key"></a>RENAMENX key new key</h3><p>当且仅当 newkey 不存在时，将 key 改名为 newkey 。<br>当 key 不存在时，返回一个错误。</p>
<h3 id="RESTORE-key-ttl-serialized-value-REPLACE"><a href="#RESTORE-key-ttl-serialized-value-REPLACE" class="headerlink" title="RESTORE key ttl serialized-value [REPLACE]"></a>RESTORE key ttl serialized-value [REPLACE]</h3><p>反序列化 </p>
<h3 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h3><p>SORT key 返回键值从小到大排序的结果。<br>SORT key DESC 返回键值从大到小排序的结果。<br>SORT {SET} ALPHA 按字符对set排序<br>LIMIT offset cout 结果集数量<br>SORT numbers STORE sorted-numbers 讲结果集保存在指定的键上</p>
<h3 id="TYPE-key"><a href="#TYPE-key" class="headerlink" title="TYPE key"></a>TYPE key</h3><p>返回key的类型<br>none (key不存在) string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表)</p>
<p>SCAN cursor [MATCH pattern] [COUNT count]<br>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：<br>SCAN 命令用于迭代当前数据库中的数据库键。<br>SSCAN 命令用于迭代集合键中的元素。<br>HSCAN 命令用于迭代哈希键中的键值对。<br>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</p>
<p>SCAN 命令是一个基于游标的迭o代器（cursor based iterator）： SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。<br>-COUNT 选项 调整一次迭代的数量<br>-MATCH 选项 scan {SET_NAME} {cursor} {RegularExpression}</p>
<h3 id="APPEND-key-value"><a href="#APPEND-key-value" class="headerlink" title="APPEND key value"></a>APPEND key value</h3><p>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行SET key value 一样。</p>
<h3 id="BITCOUNT-key-start-end"><a href="#BITCOUNT-key-start-end" class="headerlink" title="BITCOUNT key [start] [end]"></a>BITCOUNT key [start] [end]</h3><p>计算给定字符串中，被设置为 1 的比特位的数量。<br>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</p>
<h3 id="GETRANGE-key-start-end"><a href="#GETRANGE-key-start-end" class="headerlink" title="GETRANGE key start end"></a>GETRANGE key start end</h3><p>返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。</p>
<h3 id="BITOP-operation-destkey-key-key-…"><a href="#BITOP-operation-destkey-key-key-…" class="headerlink" title="BITOP operation destkey key [key …]"></a>BITOP operation destkey key [key …]</h3><p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p>
<h3 id="DECR-key"><a href="#DECR-key" class="headerlink" title="DECR key"></a>DECR key</h3><p>将 key 中储存的数字值减一。<br>1.如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。<br>2.如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br>3.本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<h3 id="DECRBY-key-decrement"><a href="#DECRBY-key-decrement" class="headerlink" title="DECRBY key decrement"></a>DECRBY key decrement</h3><p>DECR减去指定数值的版本</p>
<h3 id="GETBIT-key-offset"><a href="#GETBIT-key-offset" class="headerlink" title="GETBIT key offset"></a>GETBIT key offset</h3><p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</p>
<h3 id="GETSET-key-value"><a href="#GETSET-key-value" class="headerlink" title="GETSET key value"></a>GETSET key value</h3><p>1.将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br>2.当 key 存在但不是字符串类型时，返回一个错误。<br>3.与INCR key联用可以做计数器~</p>
<h3 id="INCR-key"><a href="#INCR-key" class="headerlink" title="INCR key"></a>INCR key</h3><p>将 key 中储存的数字值增一。</p>
<h3 id="INCRBYFLOAT-key-increment"><a href="#INCRBYFLOAT-key-increment" class="headerlink" title="INCRBYFLOAT key increment"></a>INCRBYFLOAT key increment</h3><p>为 key 中所储存的值加上浮点数增量 increment 。</p>
<h3 id="MGET-key-key-…"><a href="#MGET-key-key-…" class="headerlink" title="MGET key [key …]"></a>MGET key [key …]</h3><p>返回所有(一个或多个)给定 key 的值。</p>
<h3 id="MSET-key-value-key-value-…"><a href="#MSET-key-value-key-value-…" class="headerlink" title="MSET key value [key value …]"></a>MSET key value [key value …]</h3><p>同时设置一个或多个 key-value 对。</p>
<h3 id="MSETNX-key-value-key-value-…"><a href="#MSETNX-key-value-key-value-…" class="headerlink" title="MSETNX key value [key value …]"></a>MSETNX key value [key value …]</h3><p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<h3 id="PSETEX-key-milliseconds-value"><a href="#PSETEX-key-milliseconds-value" class="headerlink" title="PSETEX key milliseconds value"></a>PSETEX key milliseconds value</h3><p>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX命令那样，以秒为单位。</p>
<h3 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h3><p>1.将字符串值 value 关联到 key 。<br>2.如果 key 已经持有其他值， SET 就覆写旧值，无视类型。<br>3.对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。</p>
<h3 id="SETEX-key-seconds-value"><a href="#SETEX-key-seconds-value" class="headerlink" title="SETEX key seconds value"></a>SETEX key seconds value</h3><p>1.将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。<br>2如果 key 已经存在， SETEX 命令将覆写旧值。<br>3.这个命令类似于以下两个命令：<br>SET key value<br>EXPIRE key seconds  设置生存时间</p>
<h3 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h3><p>1.将 key 的值设为 value ，当且仅当 key 不存在。<br>2.若给定的 key 已经存在，则 SETNX 不做任何动作。<br>3.SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<h3 id="SETRANGE-key-offset-value"><a href="#SETRANGE-key-offset-value" class="headerlink" title="SETRANGE key offset value"></a>SETRANGE key offset value</h3><p>用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。<br>不存在的 key 当作空白字符串处理。</p>
<h3 id="STRLEN-key"><a href="#STRLEN-key" class="headerlink" title="STRLEN key"></a>STRLEN key</h3><p>返回 key 所储存的字符串值的长度。<br>当 key 储存的不是字符串值时，返回一个错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究Redis，根据官方文档抽取了些可能会忘的命令的摘要记下来，部分是自己的理解，具体内容以&lt;code&gt;redis-doc&lt;/code&gt;为准。&lt;/p&gt;
&lt;h3 id=&quot;SET-key-value-GET-key&quot;&gt;&lt;a href=&quot;#SET-key-value-GET-key&quot; class=&quot;headerlink&quot; title=&quot;SET key value/GET key&quot;&gt;&lt;/a&gt;SET key value/GET key&lt;/h3&gt;&lt;p&gt;存取值的通用方法&lt;/p&gt;
&lt;h3 id=&quot;DUMP-key&quot;&gt;&lt;a href=&quot;#DUMP-key&quot; class=&quot;headerlink&quot; title=&quot;DUMP key&quot;&gt;&lt;/a&gt;DUMP key&lt;/h3&gt;&lt;p&gt;序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为Redis 键。&lt;br&gt;序列化生成的值有以下几个特点：&lt;br&gt;1.它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。&lt;br&gt;2.值的编码格式和 RDB 文件保持一致。&lt;br&gt;3.RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。&lt;/p&gt;
&lt;h3 id=&quot;EXPIRE-key-time&quot;&gt;&lt;a href=&quot;#EXPIRE-key-time&quot; class=&quot;headerlink&quot; title=&quot;EXPIRE key time&quot;&gt;&lt;/a&gt;EXPIRE key time&lt;/h3&gt;&lt;p&gt;1.为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。&lt;br&gt;2.在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。&lt;br&gt;3.生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。同时，对已有生存时间的key执行expire命令可以更新生存时间&lt;br&gt;4.所以若不过期 返回为-1 否则返回过期时间为剩余的秒时间值，可以使用ttl查询键的生存时间&lt;/p&gt;
&lt;h3 id=&quot;EXPIREAT-key-timestamp&quot;&gt;&lt;a href=&quot;#EXPIREAT-key-timestamp&quot; class=&quot;headerlink&quot; title=&quot;EXPIREAT key timestamp&quot;&gt;&lt;/a&gt;EXPIREAT key timestamp&lt;/h3&gt;&lt;p&gt;EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。&lt;br&gt;不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。&lt;br&gt;如果生存时间设置成功，返回 1 。当 key 不存在或没办法设置生存时间，返回 0 。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://www.sequarius.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://www.sequarius.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringReloaded Spring应用的热交换技术踩坑路</title>
    <link href="https://www.sequarius.com/2016/04/03/SpringReloaded-Spring%E5%BA%94%E7%94%A8%E7%9A%84%E7%83%AD%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91%E8%B7%AF/"/>
    <id>https://www.sequarius.com/2016/04/03/SpringReloaded-Spring应用的热交换技术踩坑路/</id>
    <published>2016-04-03T09:13:47.000Z</published>
    <updated>2017-01-03T05:52:15.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Spring-Loaded"><a href="#关于Spring-Loaded" class="headerlink" title="关于Spring Loaded "></a>关于Spring Loaded </h1><p>最近在倒腾Spring全家桶的应用，在阅读<a href="http://docs.spring.io/spring-boot/docs/1.4.0.M1/reference/htmlsingle/#using-boot-hot-swapping" target="_blank" rel="external">官方文档19.5节</a>的时候无意中发现了了一个被称作hot-swapping的技术，这类在java5代理技术出现之后出现的字节码热交换技术其实也不是新鲜事，但是对于spring这样application动不动启动10来秒的框架如若使用热交换对开发效率无疑有一个质的提升，于是就根据文档踩了下坑。</p>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>如果作为gradle引入的话要稍微麻烦一点<br>首先需要加入依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &quot;org.springframework.boot:spring-boot-gradle-plugin&quot;</div><div class="line">    compile &apos;org.springframework:springloaded&apos;</div><div class="line">&#125;</div><div class="line">idea &#123;</div><div class="line">    module &#123;</div><div class="line">        inheritOutputDirs = false</div><div class="line">        outputDir = file(&quot;$buildDir/classes/main/&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">buildscript &#123;</div><div class="line">	repositories &#123;</div><div class="line">		jcenter()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>运行时加入VM参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-javaagent:&#123;path_to_jar&#125;\springloaded-1.2.5.RELEASE.jar -noverify</div></pre></td></tr></table></figure></p>
<p>如果想完成静态资源静态替换，则需要在application.properties中加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring.freemarker.cache=false //此为freemarker配置，其他模版引擎请参照文档</div></pre></td></tr></table></figure></p>
<p>完成上述配置之后便可以使用热交换插件了</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1.使用调试模式运行Spring boot application，笔者使用的IDEA为图示按钮<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/image/debug_button_localtion.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>2.修改字节码后使用上图左侧make按钮（默认快捷键alt+f9）编译新的项目，由于插件的存在，会自动将output中的代码进行热替换而无需重新启动整个application。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/image/springboot_reload_class.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>3.模版引擎在make之后也能马上变化（非Spring Loaded特性，无论是否配置Spring Loaded，静态资源替换在make候会自动生效）</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>1.如果是一般类/方法修改热替换，代理技术会起到很好的作用，但是需要注意我是我们使用的是Ioc容器，如springmvc的注解映射依赖于启动时扫描，假如替换了映射的类，springmvc并不知道这一变化，而会寻找之前的方法，这时候就会抛出找不到方法异常<br>简单看下示例<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/finduser/&#123;username&#125;"</span>)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(@PathVariable String username)</span></span>&#123;</div><div class="line"></div><div class="line">    User user=userService.findByUsername(username);</div><div class="line">    <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时我们如果把该方法改为<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/finduser/&#123;username&#125;"</span>)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findUser</span><span class="params">(@PathVariable String username)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然字节码被热替换了，但是框架抛出了异常<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java.lang.NoSuchMethodError: &#123;packagename&#125;.UserController.findUser(Ljava/lang/String;)L&#123;packagename&#125;/domain/User;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于普通类的修改，spring loaded确实是是一个很好的工具，整个make/替换过程短暂极大提升了开发效率，但对于部分ioc容器，依旧需要重启appliction才能完全看到修改后的代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于Spring-Loaded&quot;&gt;&lt;a href=&quot;#关于Spring-Loaded&quot; class=&quot;headerlink&quot; title=&quot;关于Spring Loaded &quot;&gt;&lt;/a&gt;关于Spring Loaded &lt;/h1&gt;&lt;p&gt;最近在倒腾Spring全家桶的应用，在阅读&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.4.0.M1/reference/htmlsingle/#using-boot-hot-swapping&quot;&gt;官方文档19.5节&lt;/a&gt;的时候无意中发现了了一个被称作hot-swapping的技术，这类在java5代理技术出现之后出现的字节码热交换技术其实也不是新鲜事，但是对于spring这样application动不动启动10来秒的框架如若使用热交换对开发效率无疑有一个质的提升，于是就根据文档踩了下坑。&lt;/p&gt;
&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;h2 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-devtools&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;optional&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;optional&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Gradle&quot;&gt;&lt;a href=&quot;#Gradle&quot; class=&quot;headerlink&quot; title=&quot;Gradle&quot;&gt;&lt;/a&gt;Gradle&lt;/h2&gt;&lt;p&gt;如果作为gradle引入的话要稍微麻烦一点&lt;br&gt;首先需要加入依赖&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    compile &amp;quot;org.springframework.boot:spring-boot-gradle-plugin&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    compile &amp;apos;org.springframework:springloaded&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;idea &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    module &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        inheritOutputDirs = false&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        outputDir = file(&amp;quot;$buildDir/classes/main/&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;buildscript &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	repositories &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		jcenter()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="热交换" scheme="https://www.sequarius.com/tags/%E7%83%AD%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="SpringLoaded" scheme="https://www.sequarius.com/tags/SpringLoaded/"/>
    
  </entry>
  
  <entry>
    <title>[邪教徒又一次胜利]AndroidAutoLayout实现Android多分辨率屏幕适配</title>
    <link href="https://www.sequarius.com/2015/12/21/%E9%82%AA%E6%95%99%E5%BE%92%E5%8F%88%E4%B8%80%E6%AC%A1%E8%83%9C%E5%88%A9-AndroidAutoLayout%E5%AE%9E%E7%8E%B0Android%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>https://www.sequarius.com/2015/12/21/邪教徒又一次胜利-AndroidAutoLayout实现Android多分辨率屏幕适配/</id>
    <published>2015-12-21T10:19:47.000Z</published>
    <updated>2017-01-03T05:52:17.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于屏幕适配"><a href="#关于屏幕适配" class="headerlink" title="关于屏幕适配"></a>关于屏幕适配</h1><p>&emsp;&emsp;即使android提供了像素无关密度（dp），但是由于不同设备的dpi，也不能实现不同设备上的一致效果。从初始的角度上是看，dp的初衷并不是让显示的效果在不同屏幕上一致，google 官方也是推荐尽量使用match-parent、weight、加以以dp为单位的边距来进行布局，然而，这对于某些工程来说，也没有达到完美适配的目的。所以邪教的适配方式也层出不穷。<br>例如：<br><a id="more"></a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/image/different_values.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>&emsp;&emsp;采用比例兑换的对应分辨率下的sp，产生了大量了values文件，据说优酷客户端就是这样干的。</p>
<p>&emsp;&emsp;android借鉴了CSS的精髓，提供了一个百分比布局support库<code>[com.android.support:percent]</code>，但依赖于替换原有的布局标签，同样，你如果想让一个view支持百分比，就必须在外面嵌套一个百分比布局。<br>&emsp;&emsp;android设备可谓百花齐放，然而并不是所有的设备都和Google Api设备一样，所以适配成了日常开发过程中必须要踩的坑。所谓适配，适配大致分为ROM适配，设备适配、屏幕适配。这里来记录下最近比较火的国产<a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="external">AndroidAutoLayout</a>适配方案。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;其实整个实现的代码也比较简单，总的说来就是算的过程。花了大概半个小时看完。<br>主包也只有三个，分别是：attr存放布局属性，config存放配置实现了初始化读取<code>manifest</code>、屏幕参数，utils定义了<code>AutoLayoutHelper</code>辅助布局进行参数重绘，算是这个项目的核心所在、<code>AutoUtils</code>实现了属性参数换算、<code>ScreenUtils</code>测量屏幕分辨率。<br>整理实现思路大致如下：<br>&emsp;&emsp;通过<code>AutoLayoutActivity</code>的<code>onCreateView</code>方法获得根布局属性，替换为<code>Auto***Layout</code>，layout在<code>onMesure</code>时候调用AutoLayoutHelper的<code>adjustChildren()</code>方法重新调整布局属性,遍历子控件，运算重写布局间距参数。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="1-加入依赖"><a href="#1-加入依赖" class="headerlink" title="1.加入依赖"></a>1.加入依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.zhy:autolayout:1.3.4&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-在manifest里面加入稿纸尺寸，即参考屏幕的宽高像素"><a href="#2-在manifest里面加入稿纸尺寸，即参考屏幕的宽高像素" class="headerlink" title="2.在manifest里面加入稿纸尺寸，即参考屏幕的宽高像素"></a>2.在manifest里面加入稿纸尺寸，即参考屏幕的宽高像素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;meta-data android:name=&quot;design_width&quot; android:value=&quot;720&quot;&gt;</div><div class="line">&lt;/meta-data&gt;</div><div class="line">&lt;meta-data android:name=&quot;design_height&quot; android:value=&quot;1280&quot;&gt;</div><div class="line">&lt;/meta-data&gt;</div></pre></td></tr></table></figure>
<h2 id="3-把需要自适应宽高的Activity继承于AutoLayoutActivity-或者覆写自定义的Activity中onCreateView-String-name-Context-context-AttributeSet-attrs-方法"><a href="#3-把需要自适应宽高的Activity继承于AutoLayoutActivity-或者覆写自定义的Activity中onCreateView-String-name-Context-context-AttributeSet-attrs-方法" class="headerlink" title="3.把需要自适应宽高的Activity继承于AutoLayoutActivity.或者覆写自定义的Activity中onCreateView(String name, Context context, AttributeSet attrs)方法"></a>3.把需要自适应宽高的<code>Activity</code>继承于<code>AutoLayoutActivity</code>.或者覆写自定义的<code>Activity</code>中<code>onCreateView(String name, Context context, AttributeSet attrs)</code>方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span></span></div><div class="line">&#123;</div><div class="line">    View view = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (name.equals(LAYOUT_FRAMELAYOUT))</div><div class="line">    &#123;</div><div class="line">        view = <span class="keyword">new</span> AutoFrameLayout(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name.equals(LAYOUT_LINEARLAYOUT))</div><div class="line">    &#123;</div><div class="line">        view = <span class="keyword">new</span> AutoLinearLayout(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name.equals(LAYOUT_RELATIVELAYOUT))</div><div class="line">    &#123;</div><div class="line">        view = <span class="keyword">new</span> AutoRelativeLayout(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) <span class="keyword">return</span> view;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, context, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="扩展的方法"><a href="#扩展的方法" class="headerlink" title="扩展的方法"></a>扩展的方法</h1><p>&emsp;&emsp;对于一些继承自基础布局的的布局控件，可以复写<code>generateLayoutParams(AttributeSet attrs)</code>、<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法让其支持布局自动调整<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> AutoFrameLayout.<span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoFrameLayout.LayoutParams(getContext(), attrs);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!isInEditMode())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">new</span> AutoLayoutHelper(<span class="keyword">this</span>).adjustChildren();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>1.<code>ListView</code>类因为外层布局是<code>ListView</code>所以要在获得view的时候调用<code>AutoUtils.autoSize(View view)</code>方法达到自适应的效果。</p>
<p>2.看issue据说<code>Bitmap</code>有OMM情况，这个我没验证。</p>
<p>3.作者提供了<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">app:layout_auto_basewidth="height"，代表height上编写的像素值参考宽度。</div><div class="line">app:layout_auto_baseheight="width"，代表width上编写的像素值参考高度。</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这两个方法实现了布局“高度与宽度相等”、“宽度与高度相等”在解决一些图片空间确实有一定作用。<br>4.关于性能<br>&emsp;&emsp;理论上，整个适配过程只是一个修改宽高参数的过程，并未对控件进行重绘，理论上损失的只是计算参数时的性能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于屏幕适配&quot;&gt;&lt;a href=&quot;#关于屏幕适配&quot; class=&quot;headerlink&quot; title=&quot;关于屏幕适配&quot;&gt;&lt;/a&gt;关于屏幕适配&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;即使android提供了像素无关密度（dp），但是由于不同设备的dpi，也不能实现不同设备上的一致效果。从初始的角度上是看，dp的初衷并不是让显示的效果在不同屏幕上一致，google 官方也是推荐尽量使用match-parent、weight、加以以dp为单位的边距来进行布局，然而，这对于某些工程来说，也没有达到完美适配的目的。所以邪教的适配方式也层出不穷。&lt;br&gt;例如：&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://www.sequarius.com/tags/android/"/>
    
      <category term="屏幕适配" scheme="https://www.sequarius.com/tags/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
      <category term="AutoLayout" scheme="https://www.sequarius.com/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>android基于重力感应的计步算法</title>
    <link href="https://www.sequarius.com/2015/12/16/android%E5%9F%BA%E4%BA%8E%E9%87%8D%E5%8A%9B%E6%84%9F%E5%BA%94%E7%9A%84%E8%AE%B0%E6%AD%A5%E7%AE%97%E6%B3%95/"/>
    <id>https://www.sequarius.com/2015/12/16/android基于重力感应的记步算法/</id>
    <published>2015-12-16T07:58:36.000Z</published>
    <updated>2017-01-03T05:52:16.496Z</updated>
    
    <content type="html"><![CDATA[<p>早期很多android设备并未配置陀螺仪，所以无法调用SensorManager的Sensor.TYPE_STEP_COUNTER的Sensor，试了很多算法，发现这个算法最好，<br>下面是SensorEventListener的实现，更多细节参阅<a href="https://github.com/bagilevi/android-pedometer" target="_blank" rel="external">https://github.com/bagilevi/android-pedometer</a><br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> name.bagi.levente.pedometer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.hardware.Sensor;</div><div class="line"><span class="keyword">import</span> android.hardware.SensorEvent;</div><div class="line"><span class="keyword">import</span> android.hardware.SensorEventListener;</div><div class="line"><span class="keyword">import</span> android.hardware.SensorManager;</div><div class="line"><span class="keyword">import</span> android.util.Log;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Detects steps and notifies all listeners (that implement StepListener).</div><div class="line"> * <span class="doctag">@author</span> Levente Bagi</div><div class="line"> * <span class="doctag">@todo</span> REFACTOR: SensorListener is deprecated</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StepDetector</span> <span class="keyword">implements</span> <span class="title">SensorEventListener</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">"StepDetector"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span>   mLimit = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span>   mLastValues[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>*<span class="number">2</span>];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span>   mScale[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span>   mYOffset;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span>   mLastDirections[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>*<span class="number">2</span>];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span>   mLastExtremes[][] = &#123; <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>*<span class="number">2</span>], <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>*<span class="number">2</span>] &#125;;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span>   mLastDiff[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">3</span>*<span class="number">2</span>];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     mLastMatch = -<span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ArrayList&lt;StepListener&gt; mStepListeners = <span class="keyword">new</span> ArrayList&lt;StepListener&gt;();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StepDetector</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">480</span>; <span class="comment">// <span class="doctag">TODO:</span> remove this constant</span></div><div class="line">        mYOffset = h * <span class="number">0.5f</span>;</div><div class="line">        mScale[<span class="number">0</span>] = - (h * <span class="number">0.5f</span> * (<span class="number">1.0f</span> / (SensorManager.STANDARD_GRAVITY * <span class="number">2</span>)));</div><div class="line">        mScale[<span class="number">1</span>] = - (h * <span class="number">0.5f</span> * (<span class="number">1.0f</span> / (SensorManager.MAGNETIC_FIELD_EARTH_MAX)));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSensitivity</span><span class="params">(<span class="keyword">float</span> sensitivity)</span> </span>&#123;</div><div class="line">        mLimit = sensitivity; <span class="comment">// 1.97  2.96  4.44  6.66  10.00  15.00  22.50  33.75  50.62</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStepListener</span><span class="params">(StepListener sl)</span> </span>&#123;</div><div class="line">        mStepListeners.add(sl);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//public void onSensorChanged(int sensor, float[] values) &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent event)</span> </span>&#123;</div><div class="line">        Sensor sensor = event.sensor; </div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (sensor.getType() == Sensor.TYPE_ORIENTATION) &#123;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> j = (sensor.getType() == Sensor.TYPE_ACCELEROMETER) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">float</span> vSum = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">3</span> ; i++) &#123;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> v = mYOffset + event.values[i] * mScale[j];</div><div class="line">                        vSum += v;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">float</span> v = vSum / <span class="number">3</span>;</div><div class="line">                    </div><div class="line">                    <span class="keyword">float</span> direction = (v &gt; mLastValues[k] ? <span class="number">1</span> : (v &lt; mLastValues[k] ? -<span class="number">1</span> : <span class="number">0</span>));</div><div class="line">                    <span class="keyword">if</span> (direction == - mLastDirections[k]) &#123;</div><div class="line">                        <span class="comment">// Direction changed</span></div><div class="line">                        <span class="keyword">int</span> extType = (direction &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>); <span class="comment">// minumum or maximum?</span></div><div class="line">                        mLastExtremes[extType][k] = mLastValues[k];</div><div class="line">                        <span class="keyword">float</span> diff = Math.abs(mLastExtremes[extType][k] - mLastExtremes[<span class="number">1</span> - extType][k]);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (diff &gt; mLimit) &#123;</div><div class="line">                            </div><div class="line">                            <span class="keyword">boolean</span> isAlmostAsLargeAsPrevious = diff &gt; (mLastDiff[k]*<span class="number">2</span>/<span class="number">3</span>);</div><div class="line">                            <span class="keyword">boolean</span> isPreviousLargeEnough = mLastDiff[k] &gt; (diff/<span class="number">3</span>);</div><div class="line">                            <span class="keyword">boolean</span> isNotContra = (mLastMatch != <span class="number">1</span> - extType);</div><div class="line">                            </div><div class="line">                            <span class="keyword">if</span> (isAlmostAsLargeAsPrevious &amp;&amp; isPreviousLargeEnough &amp;&amp; isNotContra) &#123;</div><div class="line">                                Log.i(TAG, <span class="string">"step"</span>);</div><div class="line">                                <span class="keyword">for</span> (StepListener stepListener : mStepListeners) &#123;</div><div class="line">                                    stepListener.onStep();</div><div class="line">                                &#125;</div><div class="line">                                mLastMatch = extType;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                mLastMatch = -<span class="number">1</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        mLastDiff[k] = diff;</div><div class="line">                    &#125;</div><div class="line">                    mLastDirections[k] = direction;</div><div class="line">                    mLastValues[k] = v;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccuracyChanged</span><span class="params">(Sensor sensor, <span class="keyword">int</span> accuracy)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早期很多android设备并未配置陀螺仪，所以无法调用SensorManager的Sensor.TYPE_STEP_COUNTER的Sensor，试了很多算法，发现这个算法最好，&lt;br&gt;下面是SensorEventListener的实现，更多细节参阅&lt;a href=&quot;https://github.com/bagilevi/android-pedometer&quot;&gt;https://github.com/bagilevi/android-pedometer&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://www.sequarius.com/tags/android/"/>
    
      <category term="计步" scheme="https://www.sequarius.com/tags/%E8%AE%A1%E6%AD%A5/"/>
    
      <category term="sensor" scheme="https://www.sequarius.com/tags/sensor/"/>
    
      <category term="pedemoter" scheme="https://www.sequarius.com/tags/pedemoter/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot 1.3.0 初探踩坑日记</title>
    <link href="https://www.sequarius.com/2015/12/06/spring-boot-1.3.0-%E5%88%9D%E6%8E%A2%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    <id>https://www.sequarius.com/2015/12/06/spring-boot-1.3.0-初探踩坑日记/</id>
    <published>2015-12-06T08:20:23.000Z</published>
    <updated>2017-01-03T05:52:16.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot介绍-引自Spring-Boot-Reference-Guide"><a href="#Spring-Boot介绍-引自Spring-Boot-Reference-Guide" class="headerlink" title="Spring Boot介绍[引自Spring Boot Reference Guide]"></a>Spring Boot介绍[引自<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="external">Spring Boot Reference Guide</a>]</h1><p>Spring Boot使开发独立的，产品级别的基于Spring的应用变得非常简单，你只需”just run”。 我们为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。多数Spring Boot应用需要很少的Spring配置。</p>
<p>你可以使用Spring Boot创建Java应用，并使用java -jar启动它或采用传统的war部署方式。我们也提供了一个运行”spring脚本”的命令行工具。</p>
<p>我们主要的目标是：</p>
<p>1.为所有的Spring开发提供一个从根本上更快的和广泛使用的入门经验。<br>2.开箱即用，但你可以通过不采用默认设置来摆脱这种方式。<br>3.提供一系列大型项目常用的非功能性特征（比如，内嵌服务器，安全，指标，健康检测，外部化配置）。<br>4.绝对不需要代码生成及XML配置。<br><a id="more"></a></p>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><h2 id="一、配置Gradle"><a href="#一、配置Gradle" class="headerlink" title="一、配置Gradle"></a>一、配置Gradle</h2><p>参照<a href="http://sequarius.github.io/2015/12/06/Gradle%E6%9E%84%E5%BB%BAspringboot%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">Gradle构建spring-boot 1.3.0 项目 基础配置</a></p>
<h2 id="二、在项目下新建一个含main-String-args-的class"><a href="#二、在项目下新建一个含main-String-args-的class" class="headerlink" title="二、在项目下新建一个含main(String[] args)的class"></a>二、在项目下新建一个含main(String[] args)的class</h2><p>1.类名上加入@SpringBootApplication 注解<br>2.为了使其能够接受http请求加入@RestController注解<br>3.写一个方法加入@@RequestMapping(URL_MAPPING)处理请求路由<br>4.在main函数创建SpringApplication实例，调用其run(String[] args)方法<br>5.Run<br><em>NOTE</em>：由于spring-boot内嵌了tomcat，所以无需web容器也可以启动web application<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTryApplication</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication  app=<span class="keyword">new</span> SpringApplication(SpringBootTryApplication.class);</div><div class="line">        app.run(args);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="几个重要注解"><a href="#几个重要注解" class="headerlink" title="几个重要注解"></a>几个重要注解</h1><p><strong>@RestController</strong>。这被称为一个构造型（stereotype）注解。它为阅读代码的人们提供建议。对于Spring，该类扮演了一个特殊角色。在本示例中，我们的类是一个web @Controller，所以当处理进来的web请求时，Spring会询问它。</p>
<p><strong>@RequestMapping</strong>注解提供路由信息。它告诉Spring任何来自”/“路径的HTTP请求都应该被映射到home方法。@RestController注解告诉Spring以字符串的形式渲染结果，并直接返回给调用者。</p>
<p><em>Note</em>：@RestController和@RequestMapping注解是Spring MVC注解（它们不是Spring Boot的特定部分）。具体查看Spring参考文档的MVC章节。</p>
<p><strong>@EnableAutoConfiguration</strong> 这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。</p>
<p><strong>@ConfigurationSpring</strong> Boot提倡基于Java的配置。尽管你可以使用一个XML源来调用SpringApplication.run()，我们通常建议你使用@Configuration类作为主要源。一般定义main方法的类也是主要@Configuration的一个很好候选。</p>
<p><em>Note</em>：很多使用XML配置的Spring配置示例已经被发布到网络上。你应该总是尽可能的使用基于Java的配置。搜索查看enable*注解就是一个好的开端。</p>
<p><strong>@SpringBootApplication</strong>很多Spring Boot开发者总是使用@Configuration，@EnableAutoConfiguration和@ComponentScan注解他们的main类。由于这些注解被如此频繁地一块使用（特别是你遵循以上最佳实践时），Spring Boot提供一个方便的@SpringBootApplication选择。<br><em>该@SpringBootApplication注解等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot介绍-引自Spring-Boot-Reference-Guide&quot;&gt;&lt;a href=&quot;#Spring-Boot介绍-引自Spring-Boot-Reference-Guide&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot介绍[引自Spring Boot Reference Guide]&quot;&gt;&lt;/a&gt;Spring Boot介绍[引自&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/&quot;&gt;Spring Boot Reference Guide&lt;/a&gt;]&lt;/h1&gt;&lt;p&gt;Spring Boot使开发独立的，产品级别的基于Spring的应用变得非常简单，你只需”just run”。 我们为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。多数Spring Boot应用需要很少的Spring配置。&lt;/p&gt;
&lt;p&gt;你可以使用Spring Boot创建Java应用，并使用java -jar启动它或采用传统的war部署方式。我们也提供了一个运行”spring脚本”的命令行工具。&lt;/p&gt;
&lt;p&gt;我们主要的目标是：&lt;/p&gt;
&lt;p&gt;1.为所有的Spring开发提供一个从根本上更快的和广泛使用的入门经验。&lt;br&gt;2.开箱即用，但你可以通过不采用默认设置来摆脱这种方式。&lt;br&gt;3.提供一系列大型项目常用的非功能性特征（比如，内嵌服务器，安全，指标，健康检测，外部化配置）。&lt;br&gt;4.绝对不需要代码生成及XML配置。&lt;br&gt;
    
    </summary>
    
    
      <category term="spring-boot" scheme="https://www.sequarius.com/tags/spring-boot/"/>
    
      <category term="rest-framework" scheme="https://www.sequarius.com/tags/rest-framework/"/>
    
      <category term="simple-guide" scheme="https://www.sequarius.com/tags/simple-guide/"/>
    
      <category term="1.3.0" scheme="https://www.sequarius.com/tags/1-3-0/"/>
    
  </entry>
  
  <entry>
    <title>Gradle构建spring-boot 1.3.0 项目 基础配置</title>
    <link href="https://www.sequarius.com/2015/12/06/Gradle%E6%9E%84%E5%BB%BAspringboot%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.sequarius.com/2015/12/06/Gradle构建springboot基础配置/</id>
    <published>2015-12-06T05:39:09.000Z</published>
    <updated>2017-01-03T05:52:08.668Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    ext &#123;</div><div class="line">        springBootVersion = &apos;1.3.0.RELEASE&apos;</div><div class="line">    &#125;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">        maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;</div><div class="line">//        maven &#123; url &quot;http://maven.oschina.net/content/groups/public/&quot; &#125; 国内源</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">apply plugin: &apos;java&apos;</div><div class="line">apply plugin: &apos;eclipse&apos;</div><div class="line">apply plugin: &apos;idea&apos;</div><div class="line">apply plugin: &apos;spring-boot&apos; </div><div class="line"></div><div class="line">jar &#123;</div><div class="line">    baseName = &apos;spring.boot&apos;</div><div class="line">    version = &apos;0.0.1-SNAPSHOT&apos;</div><div class="line">&#125;</div><div class="line">sourceCompatibility = 1.8</div><div class="line">targetCompatibility = 1.8</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">//    compile(&apos;org.springframework.boot:spring-boot-starter&apos;)</div><div class="line">    compile(&quot;org.springframework.boot:spring-boot-starter-web:$&#123;springBootVersion&#125;&quot;)</div><div class="line">    testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) </div><div class="line">&#125;</div><div class="line"></div><div class="line">eclipse &#123;</div><div class="line">    classpath &#123;</div><div class="line">         containers.remove(&apos;org.eclipse.jdt.launching.JRE_CONTAINER&apos;)</div><div class="line">         containers &apos;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">task wrapper(type: Wrapper) &#123;</div><div class="line">    gradleVersion = &apos;2.7&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;buildscript &amp;#123;&lt;/div&gt;&lt;div class=&quot;lin
    
    </summary>
    
    
      <category term="spring-boot" scheme="https://www.sequarius.com/tags/spring-boot/"/>
    
      <category term="gradle" scheme="https://www.sequarius.com/tags/gradle/"/>
    
      <category term="java" scheme="https://www.sequarius.com/tags/java/"/>
    
      <category term="rest_framework" scheme="https://www.sequarius.com/tags/rest-framework/"/>
    
  </entry>
  
  <entry>
    <title>Hexo3.1.1 github pages使用https搭建博客及踩坑录</title>
    <link href="https://www.sequarius.com/2015/12/03/Hexo3-1-1-github-pages-%E4%BD%BF%E7%94%A8https%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E8%B8%A9%E5%9D%91%E5%BD%95/"/>
    <id>https://www.sequarius.com/2015/12/03/Hexo3-1-1-github-pages-使用https搭建博客及踩坑录/</id>
    <published>2015-12-03T09:18:46.000Z</published>
    <updated>2017-01-03T05:52:19.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a>是一款基于node.js的博客框架，使用MarkDown语法进行内容编辑，与传统的wordpress等动态网站相比，博客的渲染生成均在本地完成，所生成的静态页面可以部署到<a href="https://pages.github.com/" target="_blank" rel="external">GithubPages</a>等网站，无需数据库,甚至主机主机支持。目前，hexo在github已拥有7000多start，并拥有许多实用插件以及主题元素，足以见得其受欢迎程度，本来网上已有足够多的教学帖，但大多使用的版本较老或者过为冗余，本文秉承快速入门的初衷，记录了下我在安装部署hexo的经过以及踩过的那些坑。</p>
<p><strong>note：很多童鞋因为SSHkey的关系弄了很久没有成功便放弃了，本文介绍的方法是脱离SSHkey利用https的方式的部署，如需ssh部署的请自行参阅<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a></strong><br><strong>Reference</strong>:[<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">项目地址</a>] [<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">官方文档</a>]<br><a id="more"></a></p>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="1-github"><a href="#1-github" class="headerlink" title="1.github"></a>1.github</h2><p>①登录<a href="http://www.github.com" target="_blank" rel="external">github</a>帐号，新建一个版本仓库。仓库名字为USER_NAME.github.com 这个仓库名称既为你的pages访问链接-&gt;<em>PAGES_URL</em>。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgnew_repository_in_github.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>②我选择了https的方式进行项目部署，每次部署需要输入github帐号密码进行认证，当然你也可以选择ssh的方式,已经有很多人写过了类似的教程，如若需要请自行查阅，我就不再赘述了。<br>进入主页，copy到Http的Clone地址<em>CLONE_URL</em>（即后缀为.git的地址）<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgget_repository_url.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>准备完成。</p>
<h2 id="2-本地"><a href="#2-本地" class="headerlink" title="2.本地"></a>2.本地</h2><p>1)git<br>根据系统版本到<a href="https://git-scm.com/downloads" target="_blank" rel="external">git下载页</a>下载并安装.</p>
<p>2)nodejs<br>根据系统版本到<a href="https://nodejs.org/en/download/" target="_blank" rel="external">nodejs下载页</a>下载并安装.</p>
<p>3)配置环境变量，将git nodejs npm配入环境变量。配置成功后确认能执行git node npm指令<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgcheck_for_git.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgcheck_for_node_npm.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>3)hexo 包<br>①安装hexo<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; npm install -g hexo</div></pre></td></tr></table></figure></p>
<p>②初始化hexo路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; hexo init *DIR_NAME* //FLOD_NAME为你创建给hexo的目录名字</div><div class="line">&gt; cd DIR_NAME;</div></pre></td></tr></table></figure></p>
<p>③早期的hexo包是全家桶，我找了很多之前的教学攻略都是只安装了一个hexo导致组件不全无法预览、部署，查阅了官方的文档发现了解决方案<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; npm install hexo-renderer-ejs --save //ejs</div><div class="line">&gt; npm install hexo-renderer-stylus --save</div><div class="line">&gt; npm install hexo-renderer-stylus --save</div><div class="line">&gt; npm install hexo-server //服务器模块</div><div class="line">&gt; npm install</div></pre></td></tr></table></figure></p>
<p>consle得到如下输出即为成功<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; npm install</div><div class="line">npm WARN optional dep failed, continuing fsevents@0.3.8</div><div class="line">npm WARN optional dep failed, continuing fsevents@1.0.5</div><div class="line">|</div><div class="line"></div><div class="line"></div><div class="line">&gt; dtrace-provider@0.6.0 install *HEXO_HOME*\node_modules\hexo\node_modules\buny</div><div class="line">an\node_modules\dtrace-provider</div><div class="line">&gt; node scripts/install.js</div><div class="line"></div><div class="line">hexo-generator-category@0.1.3 node_modules\hexo-generator-category</div><div class="line">├── object-assign@2.1.1</div><div class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</div><div class="line"></div><div class="line">hexo-generator-index@0.1.3 node_modules\hexo-generator-index</div><div class="line">├── object-assign@2.1.1</div><div class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</div><div class="line"></div><div class="line">hexo-generator-tag@0.1.2 node_modules\hexo-generator-tag</div><div class="line">├── object-assign@2.1.1</div><div class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</div><div class="line"></div><div class="line">hexo-generator-archive@0.1.3 node_modules\hexo-generator-archive</div><div class="line">├── object-assign@2.1.1</div><div class="line">└── hexo-pagination@0.0.2 (utils-merge@1.0.0)</div><div class="line"></div><div class="line">hexo-server@0.1.2 node_modules\hexo-server</div><div class="line">├── object-assign@2.1.1</div><div class="line">├── open@0.0.5</div><div class="line">├── mime@1.3.4</div><div class="line">├── bluebird@2.10.2</div><div class="line">├── chalk@0.5.1 (ansi-styles@1.1.0, escape-string-regexp@1.0.3, supports-colo</div><div class="line">r@0.2.0, strip-ansi@0.3.0, has-ansi@0.1.0)</div><div class="line">├── morgan@1.6.1 (on-headers@1.0.1, basic-auth@1.0.3, depd@1.0.1, on-finished</div><div class="line">@2.3.0, debug@2.2.0)</div><div class="line">├── serve-static@1.10.0 (escape-html@1.0.2, parseurl@1.3.0, send@0.13.0)</div><div class="line">├── connect@3.4.0 (parseurl@1.3.0, utils-merge@1.0.0, debug@2.2.0, finalhandl</div><div class="line">er@0.4.0)</div><div class="line">└── compression@1.6.0 (bytes@2.1.0, vary@1.1.0, on-headers@1.0.1, compressibl</div><div class="line">e@2.0.6, debug@2.2.0, accepts@1.3.0)</div><div class="line"></div><div class="line">hexo-renderer-stylus@0.3.0 node_modules\hexo-renderer-stylus</div><div class="line">├── stylus@0.52.4 (css-parse@1.7.0, debug@2.2.0, mkdirp@0.5.1, source-map@0.1</div><div class="line">.43, glob@3.2.11, sax@0.5.8)</div><div class="line">└── nib@1.1.0 (stylus@0.49.3)</div><div class="line"></div><div class="line">hexo-renderer-marked@0.2.5 node_modules\hexo-renderer-marked</div><div class="line">├── object-assign@2.1.1</div><div class="line">├── marked@0.3.5</div><div class="line">├── strip-indent@1.0.1 (get-stdin@4.0.1)</div><div class="line">└── hexo-util@0.1.7 (ent@2.2.0, bluebird@2.10.2, highlight.js@8.9.1)</div><div class="line"></div><div class="line">hexo@3.1.1 node_modules\hexo</div><div class="line">├── hexo-front-matter@0.2.2</div><div class="line">├── pretty-hrtime@1.0.1</div><div class="line">├── abbrev@1.0.7</div><div class="line">├── archy@1.0.0</div><div class="line">├── titlecase@1.0.2</div><div class="line">├── text-table@0.2.0</div><div class="line">├── strip-indent@1.0.1 (get-stdin@4.0.1)</div><div class="line">├── tildify@1.1.2 (os-homedir@1.0.1)</div><div class="line">├── chalk@1.1.1 (escape-string-regexp@1.0.3, supports-color@2.0.0, ansi-style</div><div class="line">s@2.1.0, strip-ansi@3.0.0, has-ansi@2.0.0)</div><div class="line">├── hexo-i18n@0.2.1 (sprintf-js@1.0.3)</div><div class="line">├── minimatch@2.0.10 (brace-expansion@1.1.2)</div><div class="line">├── through2@1.1.1 (xtend@4.0.1, readable-stream@1.1.13)</div><div class="line">├── bluebird@2.10.2</div><div class="line">├── swig-extras@0.0.1 (markdown@0.5.0)</div><div class="line">├── moment-timezone@0.3.1</div><div class="line">├── js-yaml@3.4.6 (inherit@2.2.2, esprima@2.7.0, argparse@1.0.3)</div><div class="line">├── warehouse@1.0.3 (graceful-fs@4.1.2, cuid@1.2.5, JSONStream@1.0.7)</div><div class="line">├── nunjucks@1.3.4 (chokidar@0.12.6, optimist@0.6.1)</div><div class="line">├── cheerio@0.19.0 (entities@1.1.1, dom-serializer@0.1.0, css-select@1.0.0, h</div><div class="line">tmlparser2@3.8.3)</div><div class="line">├── moment@2.10.6</div><div class="line">├── hexo-cli@0.1.9 (minimist@1.2.0, bluebird@3.0.6)</div><div class="line">├── lodash@3.10.1</div><div class="line">├── swig@1.4.2 (optimist@0.6.1, uglify-js@2.4.24)</div><div class="line">├── hexo-util@0.1.7 (ent@2.2.0, highlight.js@8.9.1)</div><div class="line">├── bunyan@1.5.1 (safe-json-stringify@1.0.3, dtrace-provider@0.6.0, mv@2.1.1)</div><div class="line"></div><div class="line">└── hexo-fs@0.1.5 (escape-string-regexp@1.0.3, graceful-fs@4.1.2, bluebird@3.</div><div class="line">0.6, chokidar@1.3.0)</div></pre></td></tr></table></figure></p>
<p>④生成页面<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; hexo generate //生成静态网页 hexo g也可以</div><div class="line">&gt; hexo server //启动预览服务器 hexo s也可以</div></pre></td></tr></table></figure></p>
<p><strong>note：</strong> hexo 启动的时候如果修改了markdown文件会自动生成，也就是说静态页面在启动服务器之后保存修改的文件内容会自动生成，不需要重复④步骤，直接刷新在浏览器中刷新即可查看效果，如果效果不对很有可能是markdown语法错误，这时候查看下console的输出信息。</p>
<p>⑤ 访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 你就发现新的大陆了。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgblog_preview.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;hexo new &quot;*POST_NAME*&quot; //新建文章</div><div class="line">//hexo new page &quot;*PAGE_NAME*&quot; 新建页面</div></pre></td></tr></table></figure>
<p>执行之后则会在/<em>HEXO_HOME</em>/source/_posts/POST_NAME.md生成一个markdown文件。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgpost_created.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>打开后已经具有了一个基础模版，在这里加入一个hello wold。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgpost_templete.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>启动服务器，新建的post便出现了<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://emptypointer.qiniudn.com/imgpost_helloworld.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h1 id="PUSH内容到github"><a href="#PUSH内容到github" class="headerlink" title="PUSH内容到github"></a>PUSH内容到github</h1><p>①打开/<em>HEXO_HOME</em>/_config.yml<br>在中间找到 deploy内容修改并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: *CLONE_URL* //gitclone地址</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>②部署<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; hexo deploy</div></pre></td></tr></table></figure></p>
<p>输入自己的github帐号密码等待push成功即可</p>
<p>使用浏览器中访问<a href="http://USER_NAME.github.io/" target="_blank" rel="external">http://USER_NAME.github.io/</a> (既<em>PAGES_URL</em>) 整个部署过程就完成了，是不是简单到没朋友？ </p>
<h1 id="关于Markdown-wiki"><a href="#关于Markdown-wiki" class="headerlink" title="关于Markdown[wiki]"></a>关于Markdown[<a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">wiki</a>]</h1><p>Markdown 是一种轻量级标记语言，语法也十分简单易学。</p>
<p>关于Markdown的语法学习推荐一个我无意中发现的网站<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">Cmd Markdown</a>,左边代码右边效果同步预览上手很快！<br>坑就填到这里，enjoy！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;Hexo&lt;/a&gt;是一款基于node.js的博客框架，使用MarkDown语法进行内容编辑，与传统的wordpress等动态网站相比，博客的渲染生成均在本地完成，所生成的静态页面可以部署到&lt;a href=&quot;https://pages.github.com/&quot;&gt;GithubPages&lt;/a&gt;等网站，无需数据库,甚至主机主机支持。目前，hexo在github已拥有7000多start，并拥有许多实用插件以及主题元素，足以见得其受欢迎程度，本来网上已有足够多的教学帖，但大多使用的版本较老或者过为冗余，本文秉承快速入门的初衷，记录了下我在安装部署hexo的经过以及踩过的那些坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;note：很多童鞋因为SSHkey的关系弄了很久没有成功便放弃了，本文介绍的方法是脱离SSHkey利用https的方式的部署，如需ssh部署的请自行参阅&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot;&gt;官方文档&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Reference&lt;/strong&gt;:[&lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;项目地址&lt;/a&gt;] [&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot;&gt;官方文档&lt;/a&gt;]&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://www.sequarius.com/tags/hexo/"/>
    
      <category term="github" scheme="https://www.sequarius.com/tags/github/"/>
    
      <category term="博客" scheme="https://www.sequarius.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="gitpages" scheme="https://www.sequarius.com/tags/gitpages/"/>
    
  </entry>
  
</feed>
