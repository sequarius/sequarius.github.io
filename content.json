{"meta":{"title":"Sequarius","subtitle":"A boy without story","description":"Quietly, we embrace in a world lit up by binary.","author":"Sequarius","url":"https://www.sequarius.com"},"pages":[{"title":"","date":"2017-08-06T04:34:52.669Z","updated":"2017-08-06T04:34:52.668Z","comments":false,"path":"categories/index.html","permalink":"https://www.sequarius.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-06T04:34:12.512Z","updated":"2017-08-06T04:34:12.511Z","comments":false,"path":"tags/index.html","permalink":"https://www.sequarius.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC响应H264流文件","slug":"SpringMVC响应H264流文件","date":"2018-05-28T12:27:08.000Z","updated":"2019-03-24T13:27:32.158Z","comments":true,"path":"2018/05/28/SpringMVC响应H264流文件/","link":"","permalink":"https://www.sequarius.com/2018/05/28/SpringMVC响应H264流文件/","excerpt":"","text":"随着国内带宽降费提速日益普及，与此同时移动通信技术也进一步提升，视频，直播这一类业务需求都离不开推流这一核心技术点。最近尝试了一次SpringMVC的H264流响应方法，SpringMVC提供了一个ResourceRegion对象，类比于RandomAccessFile，其抽象了资源的随机位置响应方法，所以只要用ResourceRegion响应，即可完成一个简单的H264流响应。@GetMapping(\"/play/&#123;name&#125;\")public ResponseEntity&lt;ResourceRegion&gt; play(@PathVariable(\"name\") String name,@RequestHeader HttpHeaders httpHeaders) throws IOException &#123; UrlResource video =new UrlResource(\"file:\"+ARCHIVE_DIR_STR+\"/\"+name+\".mp4\"); ResourceRegion resourceRegion = resourceRegion(video, httpHeaders); return ResponseEntity.status(HttpStatus.PARTIAL_CONTENT) .contentType(MediaTypeFactory .getMediaType(\"video/mp4\") .orElse(MediaType.APPLICATION_OCTET_STREAM)) .body(resourceRegion);&#125;private ResourceRegion resourceRegion(UrlResource video, HttpHeaders headers) throws IOException &#123; long contentLength = video.contentLength(); HttpRange range = headers.getRange().get(0); if (range != null) &#123; long start = range.getRangeStart(contentLength); long end = range.getRangeEnd(contentLength); long rangeLength = Math.min(1 * 1024 * 1024, end - start + 1); return new ResourceRegion(video, start, rangeLength); &#125; else &#123; long rangeLength = Math.min(1 * 1024 * 1024, contentLength); return new ResourceRegion(video, 0, rangeLength); &#125;&#125; 现代浏览器普遍都支持了video的tag，所以只需要在video的tag里面设置source为SpringMVC的流响应接口即可完成通过浏览器源生播放器进行播放，当然要想实现如倍速、快捷键等更多功能也可以通过其他开源播放器项目进行定制。&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;PlayPage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;video autoplay=\"autoplay\" controls&gt; &lt;source src=\"/play/name\" type=\"video/mp4\"&gt;&lt;/video&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"H264","slug":"H264","permalink":"https://www.sequarius.com/tags/H264/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.sequarius.com/tags/SpringMVC/"}]},{"title":"Kafka笔记","slug":"Kafka笔记","date":"2018-03-25T06:18:42.000Z","updated":"2018-12-16T06:22:34.546Z","comments":true,"path":"2018/03/25/Kafka笔记/","link":"","permalink":"https://www.sequarius.com/2018/03/25/Kafka笔记/","excerpt":"","text":"Kafka基础概念使用场景作为消息系统（Kafka as a Messaging System） 作为存储系统（Kafka as a Storage System） 流处理（Kafka for Stream Processing） 主题和日志主题是会被推送记录的一个类别或订阅名称 对于每一个主题，Kafka维护了一个分区日志群集! 分区日志 每个分区是一个有序的，可以不断追加消息的消息序列。分区中的每个消息都会分配一个在分区内是唯一的序列号，这个序列号叫做偏移量(offset) 核心APIPRODUCER API允许应用推送流记录到一个或多个Kafka主题上。 生产者向所选的主题发布数据。生产者负责选择哪些消息应该分配到主题内的哪个分区。这种选择分区方式，可以使用简单的循环方式负载均衡； 也可以通过一些语义分区函数实现（如：基于消息的key进行划分）。Map configs = new HashMap&lt;&gt;();configs.put...//Producer配置，这是最重要的Producer producer = new KafkaProducer&lt;&gt;(configs);//加上key会跟据消息的key进行分区划分，一般无需指定keyProducerRecord record = new ProducerRecord(topic, key, value);producer.send(record); CONSUMER API允许应用程序订阅一个或多个主题并且并处理产生的流记录 每个消费者都属于一个消费组,每一条被推送到主题的记录被传递给订阅该主题的消费组的其中一个消费者。消费者可以在不同进程或者不同的机器上。 如果所有的消费者实例有相同的消费组,消息将会有效地负载平衡给这些消费者实例。 STREAMS API允许应用程序作为一个流处理器，从一个或多个主题获取流数据，然后输出流数据到一个或多个主题，有效地将输入流转换为输出流。 如果所有的消费者实例在不同的消费组中，那么每一条消息将会被广播给所有的消费者处理。 CONNECTOR API允许构建和运行可重用的生产者（Producer)或消费者(Consumer)连接Kafka与现有应用程序或数据系统。例如,一个连接器(connector)在关系数据库中可能获取每个表变化。 逻辑图 kafka逻辑","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://www.sequarius.com/tags/笔记/"},{"name":"Kafka","slug":"Kafka","permalink":"https://www.sequarius.com/tags/Kafka/"}]},{"title":"HBase笔记","slug":"HBase笔记","date":"2018-02-15T12:27:34.000Z","updated":"2018-12-15T12:36:34.848Z","comments":true,"path":"2018/02/15/HBase笔记/","link":"","permalink":"https://www.sequarius.com/2018/02/15/HBase笔记/","excerpt":"","text":"WAL 预写式日志（Write-ahead logging，缩写 WAL）是关系数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术。在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中。 MemStore：每个Store中有一个MemStore实例。数据写入WAL之后就会被放入MemStore。MemStore是内存的存储对象，只有当MemStore满了的时候才会将数据刷写（flush）到HFile中。 HFile：在Store中有多个HFile。当MemStore满了之后HBase就会在HDFS上生成一个新的HFile，然后把MemStore中的内容写到这个HFile中。HFile直接跟HDFS打交道，它是数据的存储实体。接下来我们来解剖一下单个HFile中的成分。 WAL是存储在HDFS上的，Memstore是存储在内存中的，HFile又是存储在HDFS上的。 数据是先写入WAL，再被放入Memstore，最后被持久化到HFile中。 写入过程 WAL：数据被发出之后第一时间被写入WAL。由于WAL是基于HDFS来实现的，所以也可以说现在单元格就已经被持久化了，但是WAL只是一个暂存的日志，它是不区分Store的。这些数据是不能被直接读取和使用。 Memstore：数据随后会立即被放入Memstore中进行整理。Memstore会负责按照LSM树的结构来存放数据。这个过程就像我们在打牌的时候，抓牌之后在手上对牌进行整理的过程。 HFile：最后，当Memstore太大了达到尺寸上的阀值，或者达到了刷写时间间隔阀值的时候，HBaes会被这个Memstore的内容刷写到HDFS系统上，称为一个存储在硬盘上的HFile文件。至此，我们可以称为数据真正地被持久化到硬盘上，就算宕机，断电，数据也不会丢失了。 读出过程HBase实际的读取顺序是先从BlockCache中找数据，找不到了再去Memstore和HFile中查询数据。 Region定位 -ROOT-是一张存储META的表，META是一张存储所在region的简要信息，如起止行等信息。 从0.96版本之后这个三层查询架构被改成了二层查询架构。-ROOT-表被去掉了，同时zk中的/hbase/root-region-server也被去掉了。这回直接把.META.表所在的RegionServer信息存储到了zk中的/hbase/meta-region-server去了。再后来引入了namespace，.META.表这样别扭的名字被修改成了hbase:meta。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://www.sequarius.com/tags/笔记/"},{"name":"HBase","slug":"HBase","permalink":"https://www.sequarius.com/tags/HBase/"}]},{"title":"SpringMVC MultipartFile InputStream探秘","slug":"SpringMVC-MultipartFile-InputStream探秘","date":"2017-12-17T15:19:02.000Z","updated":"2018-11-22T14:42:51.487Z","comments":true,"path":"2017/12/17/SpringMVC-MultipartFile-InputStream探秘/","link":"","permalink":"https://www.sequarius.com/2017/12/17/SpringMVC-MultipartFile-InputStream探秘/","excerpt":"","text":"最近在一次处理上传文件的时候遇到需要guess encode问题，在使用jchardet的过程中使用UniversalDetector调用handleData(buf, 0, read)需要传入一个byte buffer，故大致写了如下一个实现试图从MultipartFile获取InputSteam然后读取buffer。@PostMapping(\"/upload\")public String upload(@RequestParam(\"file\") MultipartFile multipartFile) throws IOException &#123; log.debug(\"file name==&#123;&#125;,size==&#123;&#125;\",multipartFile.getOriginalFilename(),multipartFile.getSize()); byte[] buf = new byte[120]; int length=0; while ((length = multipartFile.getInputStream().read(buf))&gt;0)&#123; log.debug(\"bytes==&#123;&#125;\",buf); &#125; return \"ok\";&#125; 看上去简单明了，不过部署后发现程序似乎进入了infinite loop没有进行正常响应，调试进入发现程序果然陷入第5行持续循环无法结束，经过watcher发现每次loop都只read到了文件开头的字节，并未如预期read完整个Stream，难道是MultipartFile.getInputStream()实现和预想的不一样？遂step into MultipartFile.getInputStream()发现调用的是StandardMultipartHttpServletRequest的实现，StandardMultipartHttpServletRequest继承自AbstractMultipartHttpServletRequest，是对当前HttpServletRequest的封装。这看上去没什么问题，调用的是part的getInputStream()实现，没错，这里的part是javax.servlet.http.Part的JavaEE接口,具体逻辑由容器的实现。public InputStream getInputStream() throws IOException &#123; return this.part.getInputStream();&#125; 继续跟进，发现part果然进入了org.apache.catalina.core.ApplicationPart的tomcat实现public InputStream getInputStream() throws IOException &#123; return this.fileItem.getInputStream();&#125; 这里的fileItem应该是容器对于上传表单中文件的封装，继续跟进fileItem进入了org.apache.tomcat.util.http.fileupload.disk.DiskFileItem实现，下面是DiskFileItem的一些关键方法，其中dfos是一个DeferredFileOutputStream接口。private transient DeferredFileOutputStream dfos;public InputStream getInputStream() throws IOException &#123; if (!this.isInMemory()) &#123; return new FileInputStream(this.dfos.getFile()); &#125; else &#123; if (this.cachedContent == null) &#123; this.cachedContent = this.dfos.getData(); &#125; return new ByteArrayInputStream(this.cachedContent); &#125;&#125;public boolean isInMemory() &#123; return this.cachedContent != null ? true : this.dfos.isInMemory();&#125; 继续step into进入了org.apache.tomcat.util.http.fileupload.ThresholdingOutputStream，ThresholdingOutputStream是DeferredFileOutputStream的一个实现。果然在上传文件大小大于阈值时候tomcat会将内容放置在一个临时目录里，并不会持续将文件保留在内存中。有趣的是默认的threshold配置是0，换言之就是默认情况下对于上传的文件，只要存在内容，tomcat总会将其持久化，并在调用getInputStream()方法的时候创建FileInputStream返回。换言之，就是每次调用getInputStream()返回的都是一个全新的FileInputStream，也解释了为什么在调用getInputStream()总是只能读取前buffer长度的字节，一直无法读取完全的问题。其中ThresholdingOutputStream的关键代码如下。private final int threshold; //默认为0public boolean isInMemory() &#123; return !this.isThresholdExceeded();&#125;public boolean isThresholdExceeded() &#123; return this.written &gt; (long)this.threshold;&#125;","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.sequarius.com/tags/SpringMVC/"},{"name":"MultipartFile","slug":"MultipartFile","permalink":"https://www.sequarius.com/tags/MultipartFile/"}]},{"title":"JShell源码解读，REPL实现分析","slug":"JShell源码解读，Java-REPL实现分析","date":"2017-10-22T13:04:24.000Z","updated":"2018-11-06T13:50:24.137Z","comments":true,"path":"2017/10/22/JShell源码解读，Java-REPL实现分析/","link":"","permalink":"https://www.sequarius.com/2017/10/22/JShell源码解读，Java-REPL实现分析/","excerpt":"","text":"Java9不出意外的又跳票了，传闻Java9加入了JEP 222，所以用OpenJDK体验了一把JShell并分析了下其实现。 JShell简述JShell是一个能够执行Java代码片段、表达式的Shell，从外表看上去像是一个Java的解释器，实际上它是一个Read-Eval-Print Loop，接受命令、代码片段输入，输出运算结果或者一个变更状态。 JShell简易使用指北 通过${JAVA_HOME}/bin/jshell便可以启动一个JShell。 如其他Java工具一样，JShell已自带普通话补丁，在其OepnJDK源码资源文件也可以看到有l10n_zh_CN.properties的多语言支持。 执行命令类似于IPython，JShell除了可以执行Java代码，还内置了部分命令，键入\\help便可以获得命令列表。 表达式执行JShell可以直接执行一个算术表达式，输出计算值或者函数的返回值。对于单条语句，可以省略句尾句号 importJShell同时可以支持import外部包，使用Tab进行自动补全等功能。这里import还可以使用\\evn指令导入的合法classpath下的任意jar。也就是说导入 类创建初始化JShell同时可以创建初始化类实例，调用实例方法。 JShell基础对象MemoryFileManagerJShell编译器内存文件API的管理器，同时具有一个OutputMemoryJavaFileObject的Map用于类文件的缓存。 TaskFactory编译器用于解析、分析、在内存编译class文件的API基本接口，其中CompileTask、AnalyzeTask、ParseTask均继承自BaseTask，这几个Task均为TaskFactory的内部类，通过TaskFactory的工厂方法产生对应的实例。 Eval赋值引擎，将source 封装成方法、属性等等，在外部封装了imports和class，为整个JShell的核心部分 编译 声明 重定义 替换 执行 Snippet代表传递的Java代码片段，同一个片段是不可变的，这一特性也就意味着它的任意方法都会有相同的返回，并且是线程安全的。Snippet为抽象类，只有继承终点为实现类，其中派生Snippet结构如图所示。ExpressionSnippet为表达式片段，StatementSnippet为声明片段，ErroneousSnippet为非法片段，PersistentSnippet为被存储影响后续代码结果的片段。DeclarationSnippet为值片段，其下属值、类型、函数都是其实现类。 SnippetEvent直接/间接通过 JShell.eval(String)或者JShell.drop(Snippet), 或者Snippet被直接生成的关于这个变化描述的片段 ReplParserFactory继承自com.sun.tools.javac.parser.ParserFactory解析器工厂，通过com.sun.tools.javac.util.Context初始化了,com.sun.tools.javac.parser.ScannerFactory用于产生Scanner。 DiagList一个存放Snippet诊断信息的向量，这些包含是否有不可达、未声明、无法解析等错误。 MaskCommentsAndModifiers对一个输入的String，通过Context隐藏其注释和修饰符细节。 Warp将源输入包装成方法，成员变量，等等。 JShell源码分析由于时间有限，这里先把程序的主要执行逻辑写在这里，以后有时间绘成流程图。JShell.eval(String input) throws IllegalStateException -》Eval.eval(String userSource) throws IllegalStateException //初始化 -》List&lt;SnippetEvent&gt; allEvents -》Eval sourceToSnippets(String userSource) -》分析语句、通过MaskCommentsAndModifiers隐藏修饰符细节，通过工具类分析行尾，组成可以被编译的语句 -》创建ParseTask进行语义分析获得分析树List&lt;? extends Tree&gt; units -》分析units首语句类型，进入对应执行模块 -》解剖unit Eval.processVariables(String userSource, List&lt;? extends Tree&gt; units, String compileSource, ParseTask pt) -》TreeDissector.createByFirstClass(TaskFactory.BaseTask bt) -》static TreeDissector createByFirstClass(TaskFactory.BaseTask bt) &#123; Pair&lt;CompilationUnitTree, ClassTree&gt; pair = classes(bt.firstCuTree()) .findFirst().orElseGet(() -&gt; new Pair&lt;&gt;(bt.firstCuTree(), null)); return new TreeDissector(bt, pair.first, pair.second); &#125; -》根据遍历units,获取Variable基本类型、变量名、基类 VariableTree vt = (VariableTree) unitTree; String name = vt.getName().toString(); String typeName = EvalPretty.prettyExpr((JCTree) vt.getType(), false); Tree baseType = vt.getType(); -》扫描语义依赖TreeDependencyScanner.scan(Tree node) -》通过VariableTree.getInitializer();获得ExpressionTree -》Wrap.varWrap(String source, Range rtype, String brackets, Range rname, Range rinit) -》allEvents.addAll(declare(snip, snip.syntheticDiags())); JShell eval通过以上源码分析，我们我们可以通过建立一个JShell对象来尝试执行一个简单的Java程序块。 public class JShellTry &#123; public static void main(String[] args) &#123; List&lt;SnippetEvent&gt; evals = JShell.create().eval(\"System.out.print(\\\"xdsjsd\\\");\"); evals.forEach(evals-&gt; System.out.println(evals.value())); &#125;&#125; 虽然执行过程稍微长了一点，但是程序成功输出了xdsjsd，实验成功。 总结JShell为开发者提供了一个稳定的交互式终端，程序开发者可以通过JShell进行一些简单的程序执行结果验证，同时它还赋予了Java应用程序动态执行Java代码的能力，如果不出意外接下来会有很多基于JShell机制的Virtual Runtime，OJ平台出现，大家拭目以待吧！","categories":[],"tags":[{"name":"JShell","slug":"JShell","permalink":"https://www.sequarius.com/tags/JShell/"},{"name":"REPL","slug":"REPL","permalink":"https://www.sequarius.com/tags/REPL/"},{"name":"Java","slug":"Java","permalink":"https://www.sequarius.com/tags/Java/"},{"name":"JDK9","slug":"JDK9","permalink":"https://www.sequarius.com/tags/JDK9/"}]},{"title":"OkHttp开启SSL证书支持","slug":"OKHttp开启SSL证书支持","date":"2017-08-06T03:23:33.000Z","updated":"2017-08-06T04:00:55.984Z","comments":true,"path":"2017/08/06/OKHttp开启SSL证书支持/","link":"","permalink":"https://www.sequarius.com/2017/08/06/OKHttp开启SSL证书支持/","excerpt":"","text":"前段时间，遇到了一个微信支付调用Rest接口需要SSL授信的问题，遂看了一段时间自SSL证书的集成方式。 Java对安全证书的支持JDK在java.security下有一个KeyStore的工具类，可以通过工厂方法getInstance(String type, String provider)初始化一个密钥存储对象，该对象对主流的密钥格式，如PKCS12、PEM都有了默认支持。 以下是初始化密钥的方法描述。String KEYSTORE_TYPE = \"PKCS12\";try (FileInputStream fis = new FileInputStream(certPath)) &#123; // 实例化密钥库 KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE); // 加载密钥库 ks.load(fis, certPass.toCharArray()); // 实例化密钥库 KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); // 初始化密钥工厂 kmf.init(ks, certPass.toCharArray());&#125;catch (Exception e) &#123; log.error(e.getMessage(), e);&#125; SSLSocketFactory有了密钥，在应用上加解密的配置便完成了，可以使用密钥工厂对SSLSocket进行适配，产生安全连接。使用SSLContext可以初始化一个SSLSocketFactory。String PROTOCOL_TYPE = \"SSL\";SSLContext sslContext = SSLContext.getInstance(PROTOCOL_TYPE, \"SunJSSE\");sslContext.init(kmf.getKeyManagers(), null, new SecureRandom());// 获取SSLSocketFactory对象SSLSocketFactory ssf = sslContext.getSocketFactory(); 至此，整个SSL连接已经构建完成。 OkHttp使用SSLSocketFactoryOkHttpClient.Builder()提供了一个public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory, X509TrustManager trustManager)方法可以给OKhttp配置一个SSL连接工厂，所有通过该Client的Request都会附带认证信息，其中X509TrustManager为X509密钥标准的抽象管理类。 OKhttp的文档中提供了X509TrustManager的初始化方法。TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());trustManagerFactory.init((KeyStore) null);TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) &#123; throw new IllegalStateException(\"Unexpected default trust managers:\" + Arrays.toString(trustManagers)); &#125; X509TrustManager trustManager = (X509TrustManager) trustManagers[0]; 最后通过OkHttpClient okHttpClient = new OkHttpClient.Builder().sslSocketFactory(sslSocketFactory,trustManager).build()便可以完成整个Client的初始化工作。 后记作为后起之秀，OkHttp对于Java原有的证书授信机制有着深入的理解，并提供了使用SSLSocketFactory的适配方法，整个API设计简洁自然，杜绝了重复的设计。当然，没有所谓的绝对安全，对于重要的证书密钥应该妥善保管，并且及时更新，避免泄露带来的连锁反应。","categories":[],"tags":[{"name":"OkHttp","slug":"OkHttp","permalink":"https://www.sequarius.com/tags/OkHttp/"},{"name":"SSL","slug":"SSL","permalink":"https://www.sequarius.com/tags/SSL/"}]},{"title":"使用MyBatisGenerator 自定义生成的XML","slug":"使用MyBatisGenerator-自定义生成的XML","date":"2017-02-13T13:33:36.000Z","updated":"2017-02-13T13:39:37.000Z","comments":true,"path":"2017/02/13/使用MyBatisGenerator-自定义生成的XML/","link":"","permalink":"https://www.sequarius.com/2017/02/13/使用MyBatisGenerator-自定义生成的XML/","excerpt":"","text":"概述根据数据库结构生成MyBatis可以使用的ORM映射文件的工具有很多，当然最著名的是MyBatis官方的项目MyBatis Generator,该工具提供了一个可定制的ORM生成器，可以自定义生成ORM类型（XML还是基于注解）的方式，可以对表/列进行特殊定制，还可以定义数据库支持,基本主流的数据库都进行支持，项目文档也详细说明了各项配置，下面简单说几个比较常用的配置，其余细节可以参阅文档。 generatedKey&lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot; /&gt; 该节点是&lt;table&gt;节点的子节点。 通过该项配置在生成的select语句会生成keyProperty=&quot;id&quot;属性，即在调用insert(T t)或者insertSelective(T t)方法后T会在插入成功后同时被设置主键，方便后续进行updateByPrimeryKey(T t)的操作。 suppressDate&lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;&lt;/commentGenerator&gt; 该节点是&lt;context&gt;的子节点，通过该项设置可以避免生成很多无用的generate by MyBatis generator xxx之类的注解，当然如果使用maven deploy的话有没有注释影响也不是很大。 plugin&lt;plugin type=&quot;gov.sequarius.mybatis.MySQLPaginationPlugin&quot;/&gt; 该节点是&lt;context&gt; 的子节点，为生成器提供的插件支持,也是本文所介绍的重点内容，所谓插件为MyBatis Generator提供的自定义最灵活的地方，通过插件接口可以对生成的类文件、XML文件提供强大的自定义功能。 开发Plugin与PluginAdapter关系插件接口为org.mybatis.generator.api.Plugin当然这是一个最上层的接口，在同层包下提供了org.mybatis.generator.api.PluginAdapter一个适配器，可以看到官方的一些插件（位于org.mybatis。 .generator.plugins包下）基本都继承自这个抽象类，我们这里主要研究的对象也是PluginAdapter。 基础方法首先看下基本方法，对于Plugin的各类方法，PluginAdapter都进行了基础实现，抽象的方法仅仅只有boolean validate(List&lt;String&gt; warnings)一个，看名字可以猜出这是一个校验方法，用于传入warnnings来检查是否插件可用。 普通方法由于方法众多，故只寻找有代表的两个讲下，更多细节可以参考官方文档。 sqlMap???ElementGenerated(XmlElement element, IntrospectedTable introspectedTable) 该方法在基础XML生成后调用，可以看到入参有XmlElement，拿到XmlElement后就可以操作生成的XML了。 modelExampleClassGenerated(TopLevelClass, IntrospectedTable)该方法在生成modelExample时调用，如果要修改生成的modelExample内容，可以使用TopLevelClass进行反射操作。 剩下的方法基本根据命名规则都可以猜到是干什么，对于类和XML的函数参数都是一样的，只要有参数，就可以进行定制。 实战使生成的查询列表方法支持分页public class PagePlug extends PluginAdapter &#123;@Override public boolean modelExampleClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123; String pageEntityName=&quot;page&quot;; topLevelClass.addImportedType(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;)); CommentGenerator commentGenerator = context.getCommentGenerator(); Field field = new Field(); field.setVisibility(JavaVisibility.PROTECTED); field.setType(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;)); field.setName(pageEntityName); commentGenerator.addFieldComment(field, introspectedTable); topLevelClass.addField(field); char c = pageEntityName.charAt(0); String camel = Character.toUpperCase(c) + pageEntityName.substring(1); Method method = new Method(); method.setVisibility(JavaVisibility.PUBLIC); method.setName(&quot;set&quot; + camel); method.addParameter(new Parameter(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;), pageEntityName)); method.addBodyLine(&quot;this.&quot; + pageEntityName + &quot;=&quot; + pageEntityName + &quot;;&quot;); commentGenerator.addGeneralMethodComment(method, introspectedTable); topLevelClass.addMethod(method); method = new Method(); method.setVisibility(JavaVisibility.PUBLIC); method.setReturnType(new FullyQualifiedJavaType(&quot;cn.bekky.microstore.repository.mapper.page.Page&quot;)); method.setName(&quot;get&quot; + camel); method.addBodyLine(&quot;return &quot; + pageEntityName + &quot;;&quot;); commentGenerator.addGeneralMethodComment(method, introspectedTable); topLevelClass.addMethod(method); return super.modelExampleClassGenerated(topLevelClass, introspectedTable); &#125; @Override public boolean sqlMapSelectByExampleWithoutBLOBsElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123; XmlElement page = new XmlElement(&quot;if&quot;); page.addAttribute(new Attribute(&quot;test&quot;, &quot;page != null&quot;)); page.addElement(new TextElement(&quot;limit #&#123;page.begin&#125; , #&#123;page.length&#125;&quot;)); element.addElement(page); return super.sqlMapUpdateByExampleWithoutBLOBsElementGenerated(element, introspectedTable); &#125; public boolean validate(List&lt;String&gt; warnings) &#123; return true; &#125;&#125; create_time和update_time不在update时候更新public class IgnoreFieldPlug extends PluginAdapter &#123; @Override public boolean sqlMapUpdateByExampleSelectiveElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123; removeTimeAttribute(element); return super.sqlMapUpdateByExampleSelectiveElementGenerated(element, introspectedTable); &#125; @Override public boolean sqlMapUpdateByPrimaryKeySelectiveElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123; removeTimeAttribute(element); return super.sqlMapUpdateByPrimaryKeySelectiveElementGenerated(element, introspectedTable); &#125; @Override public boolean sqlMapUpdateByExampleWithoutBLOBsElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123;// removeTimeTextAttribute(element); removeTimeTextAttribute(element); return super.sqlMapUpdateByExampleWithoutBLOBsElementGenerated(element, introspectedTable); &#125; @Override public boolean sqlMapUpdateByPrimaryKeyWithoutBLOBsElementGenerated(XmlElement element, IntrospectedTable introspectedTable) &#123; removeTimeTextAttribute(element); return super.sqlMapUpdateByPrimaryKeyWithoutBLOBsElementGenerated(element, introspectedTable); &#125; private void removeTimeTextAttribute(XmlElement element) &#123; List&lt;Element&gt; elements = element.getElements(); int removeCommaIndex=0; TextElement replaceElement=null; Iterator&lt;Element&gt; iterator = elements.iterator(); while (iterator.hasNext())&#123; Element baseElements=elements.get(i); if (baseElements instanceof TextElement)&#123; TextElement targetElment=(TextElement)baseElements; if(targetElment.getContent().contains(&quot;update_time&quot;)||targetElment.getContent().contains(&quot;create_time&quot;))&#123; iterator.remove(); &#125; &#125; if (baseElements instanceof TextElement)&#123; TextElement targetElment=(TextElement)baseElements; if(targetElment.getContent().contains(&quot;where&quot;))&#123; removeCommaIndex=i-1; replaceElement=(TextElement)(elements.get(removeCommaIndex)); String content = replaceElement.getContent().trim(); replaceElement=new TextElement(content.substring(0,content.length()-1)); &#125; &#125; iterator.next(); &#125; &#125; public boolean validate(List&lt;String&gt; warnings) &#123; return true; &#125; private void removeTimeAttribute(XmlElement element) &#123; List&lt;Element&gt; elements = element.getElements(); Iterator&lt;Element&gt; iterator = elements.iterator(); while (iterator.hasNext())&#123; Element baseElements=elements.get(i); if (!(baseElements instanceof XmlElement))&#123; continue; &#125; XmlElement targetElment=(XmlElement)baseElements; if(targetElment.getName().contains(&quot;set&quot;))&#123; List&lt;Element&gt; innerElements = targetElment.getElements(); for (int i1 = 0; i1 &lt; innerElements.size(); i1++) &#123; Element baseInnerElements=elements.get(i); if (!(baseInnerElements instanceof XmlElement))&#123; continue; &#125; targetElment=(XmlElement)innerElements.get(i1); Iterator&lt;Attribute&gt; attributeIterator = targetElment.getAttributes().iterator(); while (attributeIterator.hasNext())&#123; attributeIterator.remove(); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"使用MyBatisGenerator","slug":"使用MyBatisGenerator","permalink":"https://www.sequarius.com/tags/使用MyBatisGenerator/"},{"name":"自定义生成的XML","slug":"自定义生成的XML","permalink":"https://www.sequarius.com/tags/自定义生成的XML/"}]},{"title":"基于Redis的计划任务实现","slug":"基于Redis的定时任务实现","date":"2016-09-19T13:50:14.000Z","updated":"2017-02-12T14:27:08.000Z","comments":true,"path":"2016/09/19/基于Redis的定时任务实现/","link":"","permalink":"https://www.sequarius.com/2016/09/19/基于Redis的定时任务实现/","excerpt":"","text":"使用场景常有一些使用场景，比如操作远程服务失败，需要在指定时间后重试。业务方面，比如有订单在X分钟后没有完成操作则变更状态等需求，这里使用RedisTemplete，利用expired消息实现了一个基于Redis在指时间后进行操作的服务实现。 redis 远程访问redis-cli -h {redis_host} -p {redis_port}配置修改Redis配置文件/etc/redis/redis.conf，找到bind那行配置：bind 127.0.0.1bind 0.0.0.0 指定配置文件然后重启Redis服务即可： $ sudo redis-server /etc/redis/redis.conf 键空间通知这里需要配置 notify-keyspace-events 的参数为 “Ex”。x 代表了过期事件。 notify-keyspace-events &quot;Ex&quot; 添加键值事件订阅127.0.0.1:6379&gt; psubscribe __keyevent@0__:expired 实现思路 定义一个TimeKey表示该字段已重试的次数，在开始尝试重试操作的时候校验重试次数是否达到上限，并确定下次重试时间，目前实现是以1s,10s,1min,10min,1h,3h,6h的间隔重试。 定义一个EntityKey表示该重试传入的实体，这里使用了Json序列化实体，当然也可以用其他的方法序列化，可以通过RedisSerializer&lt;T&gt;接口实现序列化与反序列化过程，并在使用RedisTemplete或者初始化时候setKeySerializer(RedisSerializer&lt;?&gt; serializer)和setValueSerializer(RedisSerializer&lt;?&gt; serializer) 定义一个NotifyKey表示订阅过期事件的key，当接受到该key过期事件的时候，检索EntityKey并分发到指定的RetryImplement。 配置redisconfig要监听过期事件，需要配置RedisMessageListenerContainerimport lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.listener.ChannelTopic;import org.springframework.data.redis.listener.RedisMessageListenerContainer;import org.springframework.data.redis.listener.Topic;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import javax.annotation.Resource;import java.util.HashSet;import java.util.Set;/** * Created by Sequarius on 2016/9/7. */@Configurationpublic class RedisConfig &#123; @Resource private JedisConnectionFactory jedisConnectionFactory; @Resource private ExpiresMessageController expiresMessageController; @Bean public StringRedisSerializer stringRedisSerializer()&#123; return new StringRedisSerializer(); &#125; @Bean public GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer()&#123; return new GenericJackson2JsonRedisSerializer(); &#125; @Bean public RedisMessageListenerContainer redisMessageListenerContainer() &#123; RedisMessageListenerContainer container = new RedisMessageListenerContainer(); container.setConnectionFactory(jedisConnectionFactory); container.setConnectionFactory(jedisConnectionFactory); Set&lt;Topic&gt; topics = new HashSet&lt;Topic&gt;() &#123;&#123; add(new ChannelTopic(&quot;__keyevent@0__:expired&quot;)); &#125;&#125;; container.addMessageListener(expiresMessageController, topics); return container; &#125; @Bean public RedisTemplate redisTemplate(RedisConnectionFactory connectionFactory, StringRedisSerializer serializer, GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer ) &#123; RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(connectionFactory); template.setKeySerializer(serializer); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); return template; &#125;&#125; 实现MessageListener接口MessageListener是接受message的一个回调接口，在public void onMessage(Message message, byte[] bytes)中回调接收到的消息，message有两个属性，一个是’byte[]’的MessageBody,一个也是byte[]的MessageChannel,该属性表示该message发生的时间频段，在这个项目下为&quot;__keyevent@0__:expired&quot;，即为0号库的过期事件。 这里使用了类名+Tag的方式标注一个unique的重试实体，在分发过程中检索对应的RetryListener初始化传入的类名进行消息分发。import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.connection.Message;import org.springframework.data.redis.connection.MessageListener;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.Resource;import java.util.HashMap;import java.util.Map;/** * Created by Sequarius on 2016/9/7. */@Componentpublic class ExpiresMessageController implements MessageListener &#123; @Resource private RedisTemplate redisTemplate; @Resource private StringRedisTemplate stringRedisTemplate; private Map&lt;String, SubMessageListener&gt; subMessageListeners; @PostConstruct void init() &#123; subMessageListeners = new HashMap&lt;&gt;(); &#125; @Override public void onMessage(Message message, byte[] bytes) &#123; byte[] bodyBytes = message.getBody(); String notifyKey = (String) stringRedisTemplate.getValueSerializer().deserialize(bodyBytes); //no subscribe for us if (!notifyKey.startsWith(Constant.PREFIX_PAYMENT_KEY)) &#123; return; &#125; String subScribeObjName = notifyKey.replaceAll(Constant.PREFIX_PAYMENT_KEY, &quot;&quot;);// Object o = redisTemplate.opsForValue().get(Constant.PREFIX_PAYMENT_ENTITY_KEY + subScribeObjName); String[] objInfo = subScribeObjName.split(&quot;:&quot;); String className = objInfo[0]; String tag=objInfo[1]; log.debug(&quot;getmessage==&#123;&#125;&quot;, notifyKey); log.debug(&quot;className==&#123;&#125;&quot;, className); try &#123; Class target=Class.forName(className); redisTemplate.setValueSerializer(new FastJsonSerializer&lt;&gt;(target)); Object o = redisTemplate.opsForValue().get(Constant.PREFIX_PAYMENT_ENTITY_KEY + subScribeObjName); subMessageListeners.get(className).onMessage(o,tag); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public &lt;E,T&gt; void addSubMessageListener(Class&lt;?&gt; clazz, SubMessageListener&lt;E,T&gt; subMessageListener) &#123; log.debug(&quot;puted:&#123;&#125;&quot;,clazz.getName()); subMessageListeners.put(clazz.getName(), subMessageListener); &#125;&#125; 实现序列化接口由于项目使用的FastJson，就用FastJson实现了一个简单的序列化与反序列化，当然在初始化传入了class，以便在反序列化时使用import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import java.nio.charset.Charset;/** * Created by Sequarius on 2016/9/8. */@Slf4jpublic class FastJsonSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; targetClass; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; try &#123; return JSON.toJSONString(t, SerializerFeature.WriteClassName) .getBytes(DEFAULT_CHARSET); &#125; catch (Exception e) &#123; log.debug(e.getMessage(), e); return new byte[0]; &#125; &#125; public FastJsonSerializer(Class&lt;T&gt; targetClass) &#123; this.targetClass = targetClass; &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String jsonStr = new String(bytes, DEFAULT_CHARSET); try &#123; return JSON.parseObject(jsonStr, targetClass); &#125; catch (Exception e) &#123; log.debug(e.getMessage(), e); return null; &#125; &#125;&#125; SubMessageListener自定义的一个消息分发，分发给指定的订阅任务，而避免了全局的广播public interface SubMessageListener&lt;E,T&gt; &#123; void onMessage(E entity,T tag);&#125; BaseRetry定义了一个基础的retry方法，提供了尝试重试等基础方法的实现，实现类自需要定义setMessageListener()并在初始化后调用便可以接收到指定Entity的消息。 import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;/** * Created by Sequarius on 2016/9/7. */@Slf4jpublic abstract class BaseRetry&lt;E, T&gt; &#123; @Resource private ExpiresMessageController expiresMessageController; @Resource private RedisTemplate redisTemplate; @Resource private StringRedisTemplate stringRedisTemplate; public Class&lt;E&gt; clazz; // 重试尝试间隔为1s,10s,1min,10min,1h,3h,6h一次递增 private final List&lt;Long&gt; RETRY_TABLE = new ArrayList&lt;Long&gt;() &#123; &#123; add(0L); add(1L); add(10L); add(60L); add(10 * 60L); add(60 * 60L); add(3 * 60 * 60L); add(6 * 60 * 60L); &#125; &#125;; public BaseRetry(Class&lt;E&gt; clazz) &#123; this.clazz = clazz; &#125; public void retry(E entity, T tag) &#123; RetryEntity retryEntity = new RetryEntity(entity, tag).invoke(); String timeKey = retryEntity.getTimeKey(); String entryKey = retryEntity.getEntryKey(); StringBuffer entityTag = retryEntity.getEntityTag(); String memoryValue = stringRedisTemplate.opsForValue().get(timeKey); int lastRetryTime = (memoryValue == null) ? 0 : Integer.valueOf(memoryValue); //first Retry save entity if (lastRetryTime == 0) &#123; redisTemplate.setDefaultSerializer(new FastJsonSerializer&lt;&gt;(clazz)); redisTemplate.opsForValue().set(entryKey, entity); &#125; //max Retry delete entity if (lastRetryTime &gt;= RETRY_TABLE.size() - 1) &#123; log.warn(&quot;retry in max times entityTag==&#123;&#125;&quot;, entityTag.toString()); log.warn(&quot;retry entity==&#123;&#125;&quot;,stringRedisTemplate.opsForValue().get(entryKey)); redisTemplate.delete(entryKey); stringRedisTemplate.delete(timeKey); throw new RetryTimeOutOfRangeException(); &#125; log.debug(&quot;time key=&#123;&#125;;entrykey=&#123;&#125;;lastRetryTime=&#123;&#125;&quot;, timeKey, entryKey, lastRetryTime); //add 1 times stringRedisTemplate.opsForValue().increment(timeKey, 1); stringRedisTemplate.opsForValue().set(entityTag.insert(0, Constant.PREFIX_PAYMENT_KEY).toString(), &quot;notify_key&quot;, RETRY_TABLE.get(lastRetryTime + 1), TimeUnit.SECONDS); &#125;// protected void addListenner(Class&lt;?&gt; clazz, SubMessageListener listener) &#123; expiresMessageController.addSubMessageListener(clazz, listener); &#125; public abstract void setMessageListener(); public void retrySuccess(E entity, T tag)&#123; RetryEntity retryEntity = new RetryEntity(entity, tag).invoke(); redisTemplate.delete(retryEntity.getTimeKey()); redisTemplate.delete(retryEntity.getEntryKey()); &#125; private class RetryEntity &#123; private E entity; private T tag; private StringBuffer entityTag; private String timeKey; private String entryKey; public RetryEntity(E entity, T tag) &#123; this.entity = entity; this.tag = tag; &#125; public StringBuffer getEntityTag() &#123; return entityTag; &#125; public String getTimeKey() &#123; return timeKey; &#125; public String getEntryKey() &#123; return entryKey; &#125; public RetryEntity invoke() &#123; entityTag = new StringBuffer(entity.getClass().getName()) .append(&quot;:&quot;).append(tag.toString()); //retry times key timeKey = new StringBuffer(Constant.PREFIX_PAYMENT_TIME_KEY).append(entityTag).toString(); //retry entity key entryKey = new StringBuffer(Constant.PREFIX_PAYMENT_ENTITY_KEY).append(entityTag).toString(); return this; &#125; &#125;&#125; 一个简单的http失败重试示例为了简单起见，这里使用了String作为Entity，通常建议使用自定义bean作为Entityimport lombok.extern.slf4j.Slf4j;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.Resource;import java.io.IOException;/** * Created by Sequarius on 2016/9/12. */@Component@Slf4jpublic class HttpGetRequestRetry extends BaseRetry&lt;String, String&gt; &#123; @Resource OkHttpClient okHttpClient; public HttpGetRequestRetry() &#123; super(String.class); &#125; @Override @PostConstruct public void setMessageListener() &#123; addListenner(String.class, new SubMessageListener&lt;String, String&gt;() &#123; @Override public void onMessage(String url, String tag) &#123; makeRequest(url, tag); &#125; &#125;); &#125; public void makeRequest(String url, String tag) &#123; Request request = new Request.Builder().url(url).get().build(); try &#123; Response response = okHttpClient.newCall(request).execute(); String body = response.body().string(); int responseCode = response.code(); if (responseCode != HttpStatus.OK.value() || !body.equals(&quot;SUCCESS&quot;)) &#123; log.warn(&quot;call back url=&#123;&#125; ,response code=&#123;&#125;,body=&#123;&#125;,fail, try again &quot;, url, responseCode, body); this.retry(url, tag); &#125;else&#123; log.debug(&quot;call back url=&#123;&#125; ,response code=&#123;&#125;,body=&#123;&#125;,ok &quot;, url, responseCode, body); retrySuccess(url,tag); &#125; &#125; catch (IOException e) &#123; log.debug(e.getMessage(), e); try &#123; this.retry(url, tag); &#125; catch (RetryTimeOutOfRangeException e1) &#123; log.error(e1.getMessage(), e); &#125; &#125; &#125;&#125; 至此，对于使用HttpGetRequestRetry的makeRequest(String url, String tag)的Http请求便可以在失败时完成重试了。","categories":[],"tags":[{"name":"Redise","slug":"Redise","permalink":"https://www.sequarius.com/tags/Redise/"},{"name":"xpired","slug":"xpired","permalink":"https://www.sequarius.com/tags/xpired/"},{"name":"失败重试","slug":"失败重试","permalink":"https://www.sequarius.com/tags/失败重试/"},{"name":"计划任务","slug":"计划任务","permalink":"https://www.sequarius.com/tags/计划任务/"}]},{"title":"RxJava初探，一些细节","slug":"RxJava初探-一些细节","date":"2016-05-26T14:25:30.000Z","updated":"2018-12-14T12:04:29.882Z","comments":true,"path":"2016/05/26/RxJava初探-一些细节/","link":"","permalink":"https://www.sequarius.com/2016/05/26/RxJava初探-一些细节/","excerpt":"RxJava 概述A library for composing asynchronous and event-based programs using observable sequences for the Java VM” 一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。 概念RxJava中观察者模式概念Observable-可观察者，即被观察者 Observer-观察者 subscribe-订阅事件。Observable 和 Observer 通过 subscribe() 。 观察者/订阅者的回调事件onNext(T t)正常的回调事件 onError(Throwable e) 异常发生时的回调事件 onCompleted() 完成时的回调事件","text":"RxJava 概述A library for composing asynchronous and event-based programs using observable sequences for the Java VM” 一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。 概念RxJava中观察者模式概念Observable-可观察者，即被观察者 Observer-观察者 subscribe-订阅事件。Observable 和 Observer 通过 subscribe() 。 观察者/订阅者的回调事件onNext(T t)正常的回调事件 onError(Throwable e) 异常发生时的回调事件 onCompleted() 完成时的回调事件 Observable 几种常见的构造方法create(new Observable.OnSubscribe()) 基础的构造方法 just(T…) 等同于onNext(t1,t2..)的调用 from(T[]) 等同于for(int i=0;i&lt;i.length;i++)&#123; onNext(t[i]); &#125; 的调用 示例@SmallTest public void testRxJava() &#123; //创建观察者 Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, &quot;completed&quot;); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;error&quot;); e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG, &quot;get string ==&quot; + s); &#125; &#125;; //创建订阅者 订阅者是观察者的一个实现类 封装了onStart() unsubscribe()等方法 Subscriber&lt;String&gt; stringSubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG, &quot;completed&quot;); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;error&quot;); e.printStackTrace(); &#125; @Override public void onNext(String s) &#123; Log.d(TAG, &quot;get string ==&quot; + s); &#125; &#125;; //构造被观察者 Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;simple&quot;); subscriber.onNext(&quot;test&quot;); subscriber.onNext(&quot;try&quot;); &#125; &#125;); //订阅观察者 Log.d(TAG, &quot;observer subscribing&quot;); observable.subscribe(observer); observable.subscribe(observer); &#125; ActionAction1、Action2、……、ActionN 是RxJava的一系列接口，只包含一个call()方法，Subscriber可以接受这一些列参数构造，产生不完整的回调。示例@MediumTest public void testAction()&#123; Action0 action=new Action0() &#123; @Override public void call() &#123; &#125; &#125;; Action1&lt;String&gt; action1=new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,&quot;action1 get == &quot;+ s); &#125; &#125;; Observable&lt;String&gt; observable=Observable.just(&quot;foo&quot;,&quot;bar&quot;,&quot;fooo&quot;,&quot;baar&quot;); observable.subscribe(action1); &#125; 此外，还有三种方法重载public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError)public final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted) 分别为支持onError、onComplted()的构造方式，可以看出,第二个方法和new Subscriber()已经并无区别了 Func如同Action,Func1,Func2,…,FuncN为Rx提供的变换函数，所谓变换就是处理加工数据的过程，如把传入的URI转换成response或是将传入的资源转换为Bitmap public static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2, T t3, T t4, T t5, T t6) 为Observable设置Fuc的方法，一个具体的示例如下@MediumTestpublic void testFunc() &#123; Observable.just(45, 48, 78, 147, 88, 488) .map(new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer integer) &#123; return String.valueOf(integer); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG, s); &#125; &#125;);&#125; 此外，还有public final &lt;R&gt; Observable&lt;R&gt; flatMap(Func1&lt;? super T, ? extends Observable&lt;? extends R&gt;&gt; func)这个方法来设置将T 转换为R[]的一转多方法。 Scheduler 概述Scheduler为RxJava的线程调度起，指定任务执行的线程 几个内置的Scheduler Schedulers.immediate():不指定运行线程直接在当前线程运行，默认设置。 Schedulers.newThread(): 在新线程执行操作。 Schedulers .io(): I/O 线程，I/O操作所使用的 Scheduler。 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。 Schedulers.computation(): 计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，使用大小为CUP核心数的的线程池。 AndroidSchedulers.mainThread()：在Android 主线程即UI线程运行。 几个重要函数public final Observable&lt;T&gt; observeOn(Scheduler scheduler)public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) 分别为指定被观察者call()方法发生线程和订阅者事件回调线程。","categories":[],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://www.sequarius.com/tags/RxJava/"}]},{"title":"一键评教是怎么通过OkHttp实现的","slug":"一键评教是怎么通过Java实现的","date":"2016-05-12T14:30:12.000Z","updated":"2017-01-03T05:52:18.797Z","comments":true,"path":"2016/05/12/一键评教是怎么通过Java实现的/","link":"","permalink":"https://www.sequarius.com/2016/05/12/一键评教是怎么通过Java实现的/","excerpt":"最近很多人问一键评教的一些细节，所以写一点在Java做爬虫程序的一些技术点。首先，什么是评教？教务系统神来之笔了一个评教系统，每门课程有大约6、7个评论选项，还要写评论，每学期课程大概有10门，最奇葩的是，如果没有完成评教请求其他的服务还会被自动拦截到评教页面，这也意味着完成这项工作耗费时间，至于对教学有没有实际作用就只有仁者见仁了。所以，在最新一版加入了自动评教功能。这篇主要说下通过OkHttp爬虫的一些细节。 如何保存保存Session？对于如何保存页面状态获取需要Session认证的方法，可以使用OkHttp的拦截器，当然，OKHttp提供了一个 CookieJar 的接口可以方便完成这个任务，这里示例是一个没有做持久化存储Cookie的示例。public class EPCookieJar implements CookieJar &#123; private final HashMap&lt;String, List&lt;Cookie&gt;&gt; cookieStore = new HashMap&lt;&gt;(); @Override public void saveFromResponse(HttpUrl httpUrl, List&lt;Cookie&gt; list) &#123; cookieStore.put(httpUrl.host(), list); &#125; @Override public List&lt;Cookie&gt; loadForRequest(HttpUrl httpUrl) &#123; List&lt;Cookie&gt; cookies = cookieStore.get(httpUrl.host()); return cookies != null ? cookies : new ArrayList&lt;Cookie&gt;(); &#125;&#125;","text":"最近很多人问一键评教的一些细节，所以写一点在Java做爬虫程序的一些技术点。首先，什么是评教？教务系统神来之笔了一个评教系统，每门课程有大约6、7个评论选项，还要写评论，每学期课程大概有10门，最奇葩的是，如果没有完成评教请求其他的服务还会被自动拦截到评教页面，这也意味着完成这项工作耗费时间，至于对教学有没有实际作用就只有仁者见仁了。所以，在最新一版加入了自动评教功能。这篇主要说下通过OkHttp爬虫的一些细节。 如何保存保存Session？对于如何保存页面状态获取需要Session认证的方法，可以使用OkHttp的拦截器，当然，OKHttp提供了一个 CookieJar 的接口可以方便完成这个任务，这里示例是一个没有做持久化存储Cookie的示例。public class EPCookieJar implements CookieJar &#123; private final HashMap&lt;String, List&lt;Cookie&gt;&gt; cookieStore = new HashMap&lt;&gt;(); @Override public void saveFromResponse(HttpUrl httpUrl, List&lt;Cookie&gt; list) &#123; cookieStore.put(httpUrl.host(), list); &#125; @Override public List&lt;Cookie&gt; loadForRequest(HttpUrl httpUrl) &#123; List&lt;Cookie&gt; cookies = cookieStore.get(httpUrl.host()); return cookies != null ? cookies : new ArrayList&lt;Cookie&gt;(); &#125;&#125; 构建请求在构建请求Builder的时候设置实现的CookieJarpublic OKHttpJar login(String username, String password) &#123; OKHttpJar OKHttpJar = new OKHttpJar(); OkHttpClient client = new OkHttpClient.Builder().cookieJar(new EPCookieJar()).build(); OKHttpJar.setClient(client); String sign = String.valueOf(System.currentTimeMillis()); FormBody formBody = new FormBody.Builder().add(&quot;Action&quot;, &quot;Login&quot;) .add(&quot;userName&quot;, username) .add(&quot;pwd&quot;, CommonUtils.getMD5String((username + sign + CommonUtils.getMD5String(password.trim())))) .add(&quot;sign&quot;, sign).build(); Request request = new Request.Builder().url(Constant.AAO_HOST + &quot;/Common/Handler/UserLogin.ashx&quot;).post(formBody).build(); JSONObject object = new JSONObject(); OKHttpJar.setJsonObject(object); try &#123; Response response = client.newCall(request).execute(); Integer resultCode = Integer.valueOf(response.body().string()); OKHttpJar.setResultCode(resultCode); switch (resultCode) &#123; case 0: break; case 2: object.put(&quot;result&quot;, false); object.put(&quot;message&quot;, &quot;账号已被封停！&quot;); break; case 4: object.put(&quot;result&quot;, false); object.put(&quot;message&quot;, &quot;账号或者密码错误！&quot;); break; default: break; &#125; &#125; catch (IOException e) &#123; OKHttpJar.setResultCode(-1); object.put(&quot;result&quot;, false); object.put(&quot;message&quot;, &quot;server error！&quot;); e.printStackTrace(); &#125; return OKHttpJar; &#125; 解析页面使用Jsoup构造Document对象，然后就可以像JavaScript操作DOM内容了。 public List&lt;ClassInfo&gt; getEvaluationList(OKHttpJar OKHttpJar) &#123; Request request = new Request.Builder().url(Constant.AAO_HOST + &quot;/TeachingEvaluation/List.aspx&quot;).get().build(); List&lt;ClassInfo&gt; classInfos = new ArrayList&lt;&gt;(); try &#123; OkHttpClient client = OKHttpJar.getClient(); Response response = client.newCall(request).execute(); String string = response.body().string();// System.out.println(string); Document parse = Jsoup.parse(string); Elements links = parse.getElementsByTag(&quot;a&quot;); for (Element link : links) &#123; String linkHref = link.attr(&quot;href&quot;); if (linkHref.contains(&quot;Eval.aspx?id=&quot;)) &#123; classInfos.add(new ClassInfo(linkHref.replace(&quot;Eval.aspx?id=&quot;, &quot;&quot;))); &#125;// String linkText = link.text(); &#125; Elements TeacherElements = parse.getElementsByAttributeValueContaining(&quot;style&quot;, &quot;width:200px;&quot;); for (int i = 0; i &lt; TeacherElements.size(); i++) &#123; classInfos.get(i).setTeacher(TeacherElements.get(i).text()); &#125; Elements ClassNameElements = parse.getElementsByAttributeValueContaining(&quot;style&quot;, &quot;width: 300px;&quot;); for (int i = 0; i &lt; ClassNameElements.size(); i++) &#123; classInfos.get(i).setClassName(ClassNameElements.get(i).text()); &#125; Elements statusElements = parse.getElementsByClass(&quot;btn_conn1&quot;); for (int i = 0; i &lt; statusElements.size(); i++) &#123; if (statusElements.get(i).text().equals(&quot;查看&quot;)) &#123; classInfos.get(i).setEvaluated(true); &#125; &#125; for (int i = 0; i &lt; classInfos.size(); i++) &#123; classInfos.get(i).setClassId(getClassID(client, classInfos.get(i))); &#125; &#125; catch (IOException e) &#123; OKHttpJar.setResultCode(-1); e.printStackTrace(); &#125; return classInfos; &#125; public String getClassID(OkHttpClient client, ClassInfo info) &#123; Request request = new Request.Builder().url(Constant.AAO_HOST + &quot;/TeachingEvaluation/Eval.aspx?id=&quot; + info.getId()).get().build(); String reslut = null; try &#123; Response response = client.newCall(request).execute(); Document parse = Jsoup.parse(response.body().string()); Elements elements = parse.getElementsByAttributeValue(&quot;name&quot;, &quot;teachclassid&quot;); for (Element element : elements) &#123; reslut = element.attr(&quot;value&quot;); &#125; __VIEWSTATEGENERATOR = parse.getElementById(&quot;__VIEWSTATEGENERATOR&quot;).attr(&quot;value&quot;); __VIEWSTATE = parse.getElementById(&quot;__VIEWSTATE&quot;).attr(&quot;value&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return reslut;&#125; 到这里就已经拿到了所有完成请求的参数信息了，剩下的就不用说了吧。这个小玩具已经被归进了SequariusToys_AAOClient项目中。","categories":[],"tags":[{"name":"OkHttp","slug":"OkHttp","permalink":"https://www.sequarius.com/tags/OkHttp/"},{"name":"OkHttp模拟登陆","slug":"OkHttp模拟登陆","permalink":"https://www.sequarius.com/tags/OkHttp模拟登陆/"}]},{"title":"Redis命令学习笔记-集合篇","slug":"Redis学习笔记-集合篇","date":"2016-05-05T13:14:50.000Z","updated":"2017-01-03T05:52:19.778Z","comments":true,"path":"2016/05/05/Redis学习笔记-集合篇/","link":"","permalink":"https://www.sequarius.com/2016/05/05/Redis学习笔记-集合篇/","excerpt":"HashHash是什么？ redis的文档解释是Redis hashes look exactly how one might expect a “hash” to look, with field-value pairs:实际是一种散列集合结构，结构也如下：{key} {domain1} {value1} {domain 2} {value2} … {domain n} {valuen} HMSET key field value [field value …]同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的域。如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。 HSET key field value将哈希表 key 中的域 field 的值设为 value 。如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。 HSETNX key field value上述版本的不覆盖set版本 如果存在返回为false HGET key field返回哈希表 key 中给定域 field 的值。","text":"HashHash是什么？ redis的文档解释是Redis hashes look exactly how one might expect a “hash” to look, with field-value pairs:实际是一种散列集合结构，结构也如下：{key} {domain1} {value1} {domain 2} {value2} … {domain n} {valuen} HMSET key field value [field value …]同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的域。如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。 HSET key field value将哈希表 key 中的域 field 的值设为 value 。如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。 HSETNX key field value上述版本的不覆盖set版本 如果存在返回为false HGET key field返回哈希表 key 中给定域 field 的值。 HMGET key field [field …]返回哈希表 key 中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个 nil 值。HSET key field value将哈希表 key 中的域 field 的值设为 value 。如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。 HGETALL key返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。 HINCRBY key field increment为哈希表 key 中的域 field 的值加上增量 increment 。增量也可以为负数，相当于对给定域进行减法操作。如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。 HINCRBYFLOAT key field increment上面命令的float版本 HINCRBY、HINCRBYFLOAT上面命令的增加指定增量版本 HLEN key返回哈希表 key 中域的数量。 HKEYS key/HVALS key返回哈希表 key 中的所有域/值。 List是一种线性的集合结构，支持常见的push/pop等操作 LPOP/LPUSH弹入弹出 BLPOP/BLPUSH阻塞版弹出/弹入原语可以在最后加入超时时间 BRPOP/BRPOP弹出List尾部元素，在尾部弹入 LINDEX key index返回列表 key 中，下标为 index 的元素。下标 LINSERT key BEFORE|AFTER pivot value将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。当 pivot 不存在于列表 key 时，不执行任何操作。当 key 不存在时， key 被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。 LRANGE key start stop返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。 LREM key count value根据参数 count 的值，移除列表中与参数 value 相等的元素。 LSET key index value将列表 key 下标为 index 的元素的值设置为 value 。当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。 LTRIM key start stop对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 SETRedis Sets are unordered collections of strings. The SADD command adds new elements to a set. It’s also possible to do a number of other operations against sets like testing if a given element already exists, performing the intersection, union or difference between multiple sets, and so forth. SADD key member [member …]将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。 SCARD key集合中元素的数量。 SDIFF key [key …]返回一个集合的全部成员，该集合是所有给定集合之间的差（补）集。不存在的 key 被视为空集。 SDIFFSTORE destination key [key …]上一个命令的保留到destination集合的版本 SINTER key [key …]返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。. SINTERSTORE destination key [key …]上一个命令的保留到destination集合的版本 SUNION key [key …]返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。 SUNIONSTORE destination key [key …]上一个命令的保留到destination集合的版本 SISMEMBER key member判断 member 元素是否集合 key 的成员。 SMEMBERS key返回集合 key 中的所有成员。不存在的 key 被视为空集合。 SMOVE source destination member将 member 元素从 source 集合移动到 destination 集合。 SRANDMEMBER key [count]如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。 SPOP key移除并返回集合中的一个随机元素。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用SRANDMEMBER 命令。 SREM key member [member …]移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误。 有序集合 SortedSet有序集合是一种带Socore的集合，可以根据score进行一些排序，查找工作。 ZADD key score member [[score member] [score member] …]将一个或多个 member 元素及其 score 值加入到有序集 key 当中。如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。 ZCARD key返回有序集 key 的基数。 ZCOUNT key min max返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或max )的成员的数量。 ZINCRBY key increment member为有序集 key 的成员 member 的 score 值加上增量 increment 。 ZRANGE key start stop [WITHSCORES]返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序( lexicographical order )来排列。 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 ZRANK key member返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。 ZREM key member [member …]移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回错误。 ZREMRANGEBYRANK key start stop移除有序集 key 中，指定排名(rank)区间内的所有成员。区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。 ZREMRANGEBYSCORE key min max移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。 ZREVRANGE key start stop [WITHSCORES]返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序的逆序( reverse lexicographical order)排列。 ZSCORE key member返回有序集 key 中，成员 member 的 score 值。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]][AGGREGATE SUM|MIN|MAX]计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。 ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]][AGGREGATE SUM|MIN|MAX]计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sequarius.com/tags/学习笔记/"},{"name":"Redis","slug":"Redis","permalink":"https://www.sequarius.com/tags/Redis/"}]},{"title":"Redis命令学习笔记part1:Key/String篇","slug":"Redis命令学习笔记part1-Key-String部分","date":"2016-04-28T07:13:52.000Z","updated":"2017-02-12T13:45:16.000Z","comments":true,"path":"2016/04/28/Redis命令学习笔记part1-Key-String部分/","link":"","permalink":"https://www.sequarius.com/2016/04/28/Redis命令学习笔记part1-Key-String部分/","excerpt":"最近在研究Redis，根据官方文档抽取了些可能会忘的命令的摘要记下来，部分是自己的理解，具体内容以redis-doc为准。 SET key value/GET key存取值的通用方法 DUMP key序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为Redis 键。序列化生成的值有以下几个特点：1.它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。2.值的编码格式和 RDB 文件保持一致。3.RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。 EXPIRE key time1.为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。2.在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。3.生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。同时，对已有生存时间的key执行expire命令可以更新生存时间4.所以若不过期 返回为-1 否则返回过期时间为剩余的秒时间值，可以使用ttl查询键的生存时间 EXPIREAT key timestampEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。如果生存时间设置成功，返回 1 。当 key 不存在或没办法设置生存时间，返回 0 。","text":"最近在研究Redis，根据官方文档抽取了些可能会忘的命令的摘要记下来，部分是自己的理解，具体内容以redis-doc为准。 SET key value/GET key存取值的通用方法 DUMP key序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为Redis 键。序列化生成的值有以下几个特点：1.它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。2.值的编码格式和 RDB 文件保持一致。3.RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。 EXPIRE key time1.为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。2.在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。3.生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。同时，对已有生存时间的key执行expire命令可以更新生存时间4.所以若不过期 返回为-1 否则返回过期时间为剩余的秒时间值，可以使用ttl查询键的生存时间 EXPIREAT key timestampEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。如果生存时间设置成功，返回 1 。当 key 不存在或没办法设置生存时间，返回 0 。 MIGRATE host port key destination-db timeout [COPY] [REPLACE]将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。原理还是使用DUMP、RESTORE进行序列化和反序列化由于这是一个原子操作，所以是阻塞执行。 MOVE key db将当前数据库的 key 移动到给定的数据库 db 当中如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果 OBJECTOBJECT 命令允许从内部察看给定 key 的 Redis 对象。-REFCOUNT 引用数目-IDLETIME 空闲时间-ENCODING 编码方式 PERSIST key移除指定key的TTL，让它获得永生。 PEXPIRE key与EXPIRE相同作用相同，只是以毫秒为时间单位 PEXPIREAT key同PEXPIRE与EXPIRE的关系 PTTL keyTTL的毫秒版 RANDOMKEY随机返回一个key，数据库为空时返回nil，抽奖程序知道怎么写了才不会被喷了吧？ RENAME key newkey改名，1.当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。2.当 newkey 已经存在时， RENAME 命令将覆盖旧值。 RENAMENX key new key当且仅当 newkey 不存在时，将 key 改名为 newkey 。当 key 不存在时，返回一个错误。 RESTORE key ttl serialized-value [REPLACE]反序列化 SORTSORT key 返回键值从小到大排序的结果。SORT key DESC 返回键值从大到小排序的结果。SORT {SET} ALPHA 按字符对set排序LIMIT offset cout 结果集数量SORT numbers STORE sorted-numbers 讲结果集保存在指定的键上 TYPE key返回key的类型none (key不存在) string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表) SCAN cursor [MATCH pattern] [COUNT count]SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：SCAN 命令用于迭代当前数据库中的数据库键。SSCAN 命令用于迭代集合键中的元素。HSCAN 命令用于迭代哈希键中的键值对。ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。 SCAN 命令是一个基于游标的迭o代器（cursor based iterator）： SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。-COUNT 选项 调整一次迭代的数量-MATCH 选项 scan {SET_NAME} {cursor} {RegularExpression} APPEND key value如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行SET key value 一样。 BITCOUNT key [start] [end]计算给定字符串中，被设置为 1 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。 GETRANGE key start end返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。 BITOP operation destkey key [key …]对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 DECR key将 key 中储存的数字值减一。1.如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。2.如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。3.本操作的值限制在 64 位(bit)有符号数字表示之内。 DECRBY key decrementDECR减去指定数值的版本 GETBIT key offset对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 GETSET key value1.将给定 key 的值设为 value ，并返回 key 的旧值(old value)。2.当 key 存在但不是字符串类型时，返回一个错误。3.与INCR key联用可以做计数器~ INCR key将 key 中储存的数字值增一。 INCRBYFLOAT key increment为 key 中所储存的值加上浮点数增量 increment 。 MGET key [key …]返回所有(一个或多个)给定 key 的值。 MSET key value [key value …]同时设置一个或多个 key-value 对。 MSETNX key value [key value …]同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 PSETEX key milliseconds value这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX命令那样，以秒为单位。 SET key value [EX seconds] [PX milliseconds] [NX|XX]1.将字符串值 value 关联到 key 。2.如果 key 已经持有其他值， SET 就覆写旧值，无视类型。3.对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。 SETEX key seconds value1.将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。2如果 key 已经存在， SETEX 命令将覆写旧值。3.这个命令类似于以下两个命令：SET key valueEXPIRE key seconds 设置生存时间 SETNX key value1.将 key 的值设为 value ，当且仅当 key 不存在。2.若给定的 key 已经存在，则 SETNX 不做任何动作。3.SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。 SETRANGE key offset value用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。不存在的 key 当作空白字符串处理。 STRLEN key返回 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sequarius.com/tags/学习笔记/"},{"name":"Redis","slug":"Redis","permalink":"https://www.sequarius.com/tags/Redis/"}]},{"title":"SpringReloaded Spring应用的热交换技术踩坑路","slug":"SpringReloaded-Spring应用的热交换技术踩坑路","date":"2016-04-03T09:13:47.000Z","updated":"2017-01-03T05:52:15.938Z","comments":true,"path":"2016/04/03/SpringReloaded-Spring应用的热交换技术踩坑路/","link":"","permalink":"https://www.sequarius.com/2016/04/03/SpringReloaded-Spring应用的热交换技术踩坑路/","excerpt":"关于Spring Loaded 最近在倒腾Spring全家桶的应用，在阅读官方文档19.5节的时候无意中发现了了一个被称作hot-swapping的技术，这类在java5代理技术出现之后出现的字节码热交换技术其实也不是新鲜事，但是对于spring这样application动不动启动10来秒的框架如若使用热交换对开发效率无疑有一个质的提升，于是就根据文档踩了下坑。 引入Maven&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle如果作为gradle引入的话要稍微麻烦一点首先需要加入依赖dependencies &#123; compile &quot;org.springframework.boot:spring-boot-gradle-plugin&quot; compile &apos;org.springframework:springloaded&apos;&#125;idea &#123; module &#123; inheritOutputDirs = false outputDir = file(&quot;$buildDir/classes/main/&quot;) &#125;&#125;buildscript &#123; repositories &#123; jcenter() &#125;&#125;","text":"关于Spring Loaded 最近在倒腾Spring全家桶的应用，在阅读官方文档19.5节的时候无意中发现了了一个被称作hot-swapping的技术，这类在java5代理技术出现之后出现的字节码热交换技术其实也不是新鲜事，但是对于spring这样application动不动启动10来秒的框架如若使用热交换对开发效率无疑有一个质的提升，于是就根据文档踩了下坑。 引入Maven&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle如果作为gradle引入的话要稍微麻烦一点首先需要加入依赖dependencies &#123; compile &quot;org.springframework.boot:spring-boot-gradle-plugin&quot; compile &apos;org.springframework:springloaded&apos;&#125;idea &#123; module &#123; inheritOutputDirs = false outputDir = file(&quot;$buildDir/classes/main/&quot;) &#125;&#125;buildscript &#123; repositories &#123; jcenter() &#125;&#125; 运行时加入VM参数-javaagent:&#123;path_to_jar&#125;\\springloaded-1.2.5.RELEASE.jar -noverify 如果想完成静态资源静态替换，则需要在application.properties中加入spring.freemarker.cache=false //此为freemarker配置，其他模版引擎请参照文档 完成上述配置之后便可以使用热交换插件了 使用1.使用调试模式运行Spring boot application，笔者使用的IDEA为图示按钮 2.修改字节码后使用上图左侧make按钮（默认快捷键alt+f9）编译新的项目，由于插件的存在，会自动将output中的代码进行热替换而无需重新启动整个application。 3.模版引擎在make之后也能马上变化（非Spring Loaded特性，无论是否配置Spring Loaded，静态资源替换在make候会自动生效） 坑1.如果是一般类/方法修改热替换，代理技术会起到很好的作用，但是需要注意我是我们使用的是Ioc容器，如springmvc的注解映射依赖于启动时扫描，假如替换了映射的类，springmvc并不知道这一变化，而会寻找之前的方法，这时候就会抛出找不到方法异常简单看下示例@RequestMapping(\"/finduser/&#123;username&#125;\")@ResponseBodypublic User findUser(@PathVariable String username)&#123; User user=userService.findByUsername(username); return user;&#125; 此时我们如果把该方法改为@RequestMapping(\"/finduser/&#123;username&#125;\")@ResponseBodypublic String findUser(@PathVariable String username)&#123; return \"ok\";&#125; 虽然字节码被热替换了，但是框架抛出了异常java.lang.NoSuchMethodError: &#123;packagename&#125;.UserController.findUser(Ljava/lang/String;)L&#123;packagename&#125;/domain/User; 总结对于普通类的修改，spring loaded确实是是一个很好的工具，整个make/替换过程短暂极大提升了开发效率，但对于部分ioc容器，依旧需要重启appliction才能完全看到修改后的代码。","categories":[],"tags":[{"name":"热交换","slug":"热交换","permalink":"https://www.sequarius.com/tags/热交换/"},{"name":"SpringLoaded","slug":"SpringLoaded","permalink":"https://www.sequarius.com/tags/SpringLoaded/"}]},{"title":"[邪教徒又一次胜利]AndroidAutoLayout实现Android多分辨率屏幕适配","slug":"邪教徒又一次胜利-AndroidAutoLayout实现Android多分辨率屏幕适配","date":"2015-12-21T10:19:47.000Z","updated":"2017-01-03T05:52:17.451Z","comments":true,"path":"2015/12/21/邪教徒又一次胜利-AndroidAutoLayout实现Android多分辨率屏幕适配/","link":"","permalink":"https://www.sequarius.com/2015/12/21/邪教徒又一次胜利-AndroidAutoLayout实现Android多分辨率屏幕适配/","excerpt":"关于屏幕适配&emsp;&emsp;即使android提供了像素无关密度（dp），但是由于不同设备的dpi，也不能实现不同设备上的一致效果。从初始的角度上是看，dp的初衷并不是让显示的效果在不同屏幕上一致，google 官方也是推荐尽量使用match-parent、weight、加以以dp为单位的边距来进行布局，然而，这对于某些工程来说，也没有达到完美适配的目的。所以邪教的适配方式也层出不穷。例如：","text":"关于屏幕适配&emsp;&emsp;即使android提供了像素无关密度（dp），但是由于不同设备的dpi，也不能实现不同设备上的一致效果。从初始的角度上是看，dp的初衷并不是让显示的效果在不同屏幕上一致，google 官方也是推荐尽量使用match-parent、weight、加以以dp为单位的边距来进行布局，然而，这对于某些工程来说，也没有达到完美适配的目的。所以邪教的适配方式也层出不穷。例如： &emsp;&emsp;采用比例兑换的对应分辨率下的sp，产生了大量了values文件，据说优酷客户端就是这样干的。 &emsp;&emsp;android借鉴了CSS的精髓，提供了一个百分比布局support库[com.android.support:percent]，但依赖于替换原有的布局标签，同样，你如果想让一个view支持百分比，就必须在外面嵌套一个百分比布局。&emsp;&emsp;android设备可谓百花齐放，然而并不是所有的设备都和Google Api设备一样，所以适配成了日常开发过程中必须要踩的坑。所谓适配，适配大致分为ROM适配，设备适配、屏幕适配。这里来记录下最近比较火的国产AndroidAutoLayout适配方案。 原理&emsp;&emsp;其实整个实现的代码也比较简单，总的说来就是算的过程。花了大概半个小时看完。主包也只有三个，分别是：attr存放布局属性，config存放配置实现了初始化读取manifest、屏幕参数，utils定义了AutoLayoutHelper辅助布局进行参数重绘，算是这个项目的核心所在、AutoUtils实现了属性参数换算、ScreenUtils测量屏幕分辨率。整理实现思路大致如下：&emsp;&emsp;通过AutoLayoutActivity的onCreateView方法获得根布局属性，替换为Auto***Layout，layout在onMesure时候调用AutoLayoutHelper的adjustChildren()方法重新调整布局属性,遍历子控件，运算重写布局间距参数。 使用1.加入依赖dependencies &#123; compile &apos;com.zhy:autolayout:1.3.4&apos;&#125; 2.在manifest里面加入稿纸尺寸，即参考屏幕的宽高像素&lt;meta-data android:name=&quot;design_width&quot; android:value=&quot;720&quot;&gt;&lt;/meta-data&gt;&lt;meta-data android:name=&quot;design_height&quot; android:value=&quot;1280&quot;&gt;&lt;/meta-data&gt; 3.把需要自适应宽高的Activity继承于AutoLayoutActivity.或者覆写自定义的Activity中onCreateView(String name, Context context, AttributeSet attrs)方法@Overridepublic View onCreateView(String name, Context context, AttributeSet attrs)&#123; View view = null; if (name.equals(LAYOUT_FRAMELAYOUT)) &#123; view = new AutoFrameLayout(context, attrs); &#125; if (name.equals(LAYOUT_LINEARLAYOUT)) &#123; view = new AutoLinearLayout(context, attrs); &#125; if (name.equals(LAYOUT_RELATIVELAYOUT)) &#123; view = new AutoRelativeLayout(context, attrs); &#125; if (view != null) return view; return super.onCreateView(name, context, attrs);&#125; 扩展的方法&emsp;&emsp;对于一些继承自基础布局的的布局控件，可以复写generateLayoutParams(AttributeSet attrs)、onMeasure(int widthMeasureSpec, int heightMeasureSpec)方法让其支持布局自动调整@Overridepublic AutoFrameLayout.LayoutParams generateLayoutParams(AttributeSet attrs)&#123; return new AutoFrameLayout.LayoutParams(getContext(), attrs);&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)&#123; if (!isInEditMode()) &#123; new AutoLayoutHelper(this).adjustChildren(); &#125; super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; 后记1.ListView类因为外层布局是ListView所以要在获得view的时候调用AutoUtils.autoSize(View view)方法达到自适应的效果。 2.看issue据说Bitmap有OMM情况，这个我没验证。 3.作者提供了app:layout_auto_basewidth=\"height\"，代表height上编写的像素值参考宽度。app:layout_auto_baseheight=\"width\"，代表width上编写的像素值参考高度。 &emsp;&emsp;这两个方法实现了布局“高度与宽度相等”、“宽度与高度相等”在解决一些图片空间确实有一定作用。4.关于性能&emsp;&emsp;理论上，整个适配过程只是一个修改宽高参数的过程，并未对控件进行重绘，理论上损失的只是计算参数时的性能。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://www.sequarius.com/tags/android/"},{"name":"屏幕适配","slug":"屏幕适配","permalink":"https://www.sequarius.com/tags/屏幕适配/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://www.sequarius.com/tags/AutoLayout/"}]},{"title":"android基于重力感应的计步算法","slug":"android基于重力感应的记步算法","date":"2015-12-16T07:58:36.000Z","updated":"2017-01-03T05:52:16.496Z","comments":true,"path":"2015/12/16/android基于重力感应的记步算法/","link":"","permalink":"https://www.sequarius.com/2015/12/16/android基于重力感应的记步算法/","excerpt":"早期很多android设备并未配置陀螺仪，所以无法调用SensorManager的Sensor.TYPE_STEP_COUNTER的Sensor，试了很多算法，发现这个算法最好，下面是SensorEventListener的实现，更多细节参阅https://github.com/bagilevi/android-pedometer","text":"早期很多android设备并未配置陀螺仪，所以无法调用SensorManager的Sensor.TYPE_STEP_COUNTER的Sensor，试了很多算法，发现这个算法最好，下面是SensorEventListener的实现，更多细节参阅https://github.com/bagilevi/android-pedometerpackage name.bagi.levente.pedometer;import java.util.ArrayList;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.util.Log;/** * Detects steps and notifies all listeners (that implement StepListener). * @author Levente Bagi * @todo REFACTOR: SensorListener is deprecated */public class StepDetector implements SensorEventListener&#123; private final static String TAG = \"StepDetector\"; private float mLimit = 10; private float mLastValues[] = new float[3*2]; private float mScale[] = new float[2]; private float mYOffset; private float mLastDirections[] = new float[3*2]; private float mLastExtremes[][] = &#123; new float[3*2], new float[3*2] &#125;; private float mLastDiff[] = new float[3*2]; private int mLastMatch = -1; private ArrayList&lt;StepListener&gt; mStepListeners = new ArrayList&lt;StepListener&gt;(); public StepDetector() &#123; int h = 480; // TODO: remove this constant mYOffset = h * 0.5f; mScale[0] = - (h * 0.5f * (1.0f / (SensorManager.STANDARD_GRAVITY * 2))); mScale[1] = - (h * 0.5f * (1.0f / (SensorManager.MAGNETIC_FIELD_EARTH_MAX))); &#125; public void setSensitivity(float sensitivity) &#123; mLimit = sensitivity; // 1.97 2.96 4.44 6.66 10.00 15.00 22.50 33.75 50.62 &#125; public void addStepListener(StepListener sl) &#123; mStepListeners.add(sl); &#125; //public void onSensorChanged(int sensor, float[] values) &#123; public void onSensorChanged(SensorEvent event) &#123; Sensor sensor = event.sensor; synchronized (this) &#123; if (sensor.getType() == Sensor.TYPE_ORIENTATION) &#123; &#125; else &#123; int j = (sensor.getType() == Sensor.TYPE_ACCELEROMETER) ? 1 : 0; if (j == 1) &#123; float vSum = 0; for (int i=0 ; i&lt;3 ; i++) &#123; final float v = mYOffset + event.values[i] * mScale[j]; vSum += v; &#125; int k = 0; float v = vSum / 3; float direction = (v &gt; mLastValues[k] ? 1 : (v &lt; mLastValues[k] ? -1 : 0)); if (direction == - mLastDirections[k]) &#123; // Direction changed int extType = (direction &gt; 0 ? 0 : 1); // minumum or maximum? mLastExtremes[extType][k] = mLastValues[k]; float diff = Math.abs(mLastExtremes[extType][k] - mLastExtremes[1 - extType][k]); if (diff &gt; mLimit) &#123; boolean isAlmostAsLargeAsPrevious = diff &gt; (mLastDiff[k]*2/3); boolean isPreviousLargeEnough = mLastDiff[k] &gt; (diff/3); boolean isNotContra = (mLastMatch != 1 - extType); if (isAlmostAsLargeAsPrevious &amp;&amp; isPreviousLargeEnough &amp;&amp; isNotContra) &#123; Log.i(TAG, \"step\"); for (StepListener stepListener : mStepListeners) &#123; stepListener.onStep(); &#125; mLastMatch = extType; &#125; else &#123; mLastMatch = -1; &#125; &#125; mLastDiff[k] = diff; &#125; mLastDirections[k] = direction; mLastValues[k] = v; &#125; &#125; &#125; &#125; public void onAccuracyChanged(Sensor sensor, int accuracy) &#123; // TODO Auto-generated method stub &#125;&#125;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://www.sequarius.com/tags/android/"},{"name":"计步","slug":"计步","permalink":"https://www.sequarius.com/tags/计步/"},{"name":"sensor","slug":"sensor","permalink":"https://www.sequarius.com/tags/sensor/"},{"name":"pedemoter","slug":"pedemoter","permalink":"https://www.sequarius.com/tags/pedemoter/"}]},{"title":"spring-boot 1.3.0 初探踩坑日记","slug":"spring-boot-1.3.0-初探踩坑日记","date":"2015-12-06T08:20:23.000Z","updated":"2017-01-03T05:52:16.292Z","comments":true,"path":"2015/12/06/spring-boot-1.3.0-初探踩坑日记/","link":"","permalink":"https://www.sequarius.com/2015/12/06/spring-boot-1.3.0-初探踩坑日记/","excerpt":"Spring Boot介绍[引自Spring Boot Reference Guide]Spring Boot使开发独立的，产品级别的基于Spring的应用变得非常简单，你只需”just run”。 我们为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。多数Spring Boot应用需要很少的Spring配置。 你可以使用Spring Boot创建Java应用，并使用java -jar启动它或采用传统的war部署方式。我们也提供了一个运行”spring脚本”的命令行工具。 我们主要的目标是： 1.为所有的Spring开发提供一个从根本上更快的和广泛使用的入门经验。2.开箱即用，但你可以通过不采用默认设置来摆脱这种方式。3.提供一系列大型项目常用的非功能性特征（比如，内嵌服务器，安全，指标，健康检测，外部化配置）。4.绝对不需要代码生成及XML配置。","text":"Spring Boot介绍[引自Spring Boot Reference Guide]Spring Boot使开发独立的，产品级别的基于Spring的应用变得非常简单，你只需”just run”。 我们为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。多数Spring Boot应用需要很少的Spring配置。 你可以使用Spring Boot创建Java应用，并使用java -jar启动它或采用传统的war部署方式。我们也提供了一个运行”spring脚本”的命令行工具。 我们主要的目标是： 1.为所有的Spring开发提供一个从根本上更快的和广泛使用的入门经验。2.开箱即用，但你可以通过不采用默认设置来摆脱这种方式。3.提供一系列大型项目常用的非功能性特征（比如，内嵌服务器，安全，指标，健康检测，外部化配置）。4.绝对不需要代码生成及XML配置。 构建一、配置Gradle参照Gradle构建spring-boot 1.3.0 项目 基础配置 二、在项目下新建一个含main(String[] args)的class1.类名上加入@SpringBootApplication 注解2.为了使其能够接受http请求加入@RestController注解3.写一个方法加入@@RequestMapping(URL_MAPPING)处理请求路由4.在main函数创建SpringApplication实例，调用其run(String[] args)方法5.RunNOTE：由于spring-boot内嵌了tomcat，所以无需web容器也可以启动web application@SpringBootApplication@RestControllerpublic class SpringBootTryApplication &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) &#123; SpringApplication app=new SpringApplication(SpringBootTryApplication.class); app.run(args); &#125;&#125; 几个重要注解@RestController。这被称为一个构造型（stereotype）注解。它为阅读代码的人们提供建议。对于Spring，该类扮演了一个特殊角色。在本示例中，我们的类是一个web @Controller，所以当处理进来的web请求时，Spring会询问它。 @RequestMapping注解提供路由信息。它告诉Spring任何来自”/“路径的HTTP请求都应该被映射到home方法。@RestController注解告诉Spring以字符串的形式渲染结果，并直接返回给调用者。 Note：@RestController和@RequestMapping注解是Spring MVC注解（它们不是Spring Boot的特定部分）。具体查看Spring参考文档的MVC章节。 @EnableAutoConfiguration 这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。 @ConfigurationSpring Boot提倡基于Java的配置。尽管你可以使用一个XML源来调用SpringApplication.run()，我们通常建议你使用@Configuration类作为主要源。一般定义main方法的类也是主要@Configuration的一个很好候选。 Note：很多使用XML配置的Spring配置示例已经被发布到网络上。你应该总是尽可能的使用基于Java的配置。搜索查看enable*注解就是一个好的开端。 @SpringBootApplication很多Spring Boot开发者总是使用@Configuration，@EnableAutoConfiguration和@ComponentScan注解他们的main类。由于这些注解被如此频繁地一块使用（特别是你遵循以上最佳实践时），Spring Boot提供一个方便的@SpringBootApplication选择。该@SpringBootApplication注解等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan。","categories":[],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"https://www.sequarius.com/tags/spring-boot/"},{"name":"rest-framework","slug":"rest-framework","permalink":"https://www.sequarius.com/tags/rest-framework/"},{"name":"simple-guide","slug":"simple-guide","permalink":"https://www.sequarius.com/tags/simple-guide/"},{"name":"1.3.0","slug":"1-3-0","permalink":"https://www.sequarius.com/tags/1-3-0/"}]},{"title":"Gradle构建spring-boot 1.3.0 项目 基础配置","slug":"Gradle构建springboot基础配置","date":"2015-12-06T05:39:09.000Z","updated":"2017-01-03T05:52:08.668Z","comments":true,"path":"2015/12/06/Gradle构建springboot基础配置/","link":"","permalink":"https://www.sequarius.com/2015/12/06/Gradle构建springboot基础配置/","excerpt":"","text":"buildscript &#123; ext &#123; springBootVersion = &apos;1.3.0.RELEASE&apos; &#125; repositories &#123; jcenter() maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;// maven &#123; url &quot;http://maven.oschina.net/content/groups/public/&quot; &#125; 国内源 &#125; dependencies &#123; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) &#125;&#125;apply plugin: &apos;java&apos;apply plugin: &apos;eclipse&apos;apply plugin: &apos;idea&apos;apply plugin: &apos;spring-boot&apos; jar &#123; baseName = &apos;spring.boot&apos; version = &apos;0.0.1-SNAPSHOT&apos;&#125;sourceCompatibility = 1.8targetCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123;// compile(&apos;org.springframework.boot:spring-boot-starter&apos;) compile(&quot;org.springframework.boot:spring-boot-starter-web:$&#123;springBootVersion&#125;&quot;) testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) &#125;eclipse &#123; classpath &#123; containers.remove(&apos;org.eclipse.jdt.launching.JRE_CONTAINER&apos;) containers &apos;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8&apos; &#125;&#125;task wrapper(type: Wrapper) &#123; gradleVersion = &apos;2.7&apos;&#125;","categories":[],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"https://www.sequarius.com/tags/spring-boot/"},{"name":"gradle","slug":"gradle","permalink":"https://www.sequarius.com/tags/gradle/"},{"name":"java","slug":"java","permalink":"https://www.sequarius.com/tags/java/"},{"name":"rest_framework","slug":"rest-framework","permalink":"https://www.sequarius.com/tags/rest-framework/"}]},{"title":"Hexo3.1.1 github pages使用https搭建博客及踩坑录","slug":"Hexo3-1-1-github-pages-使用https搭建博客及踩坑录","date":"2015-12-03T09:18:46.000Z","updated":"2018-12-04T13:32:14.667Z","comments":true,"path":"2015/12/03/Hexo3-1-1-github-pages-使用https搭建博客及踩坑录/","link":"","permalink":"https://www.sequarius.com/2015/12/03/Hexo3-1-1-github-pages-使用https搭建博客及踩坑录/","excerpt":"概述Hexo是一款基于node.js的博客框架，使用MarkDown语法进行内容编辑，与传统的wordpress等动态网站相比，博客的渲染生成均在本地完成，所生成的静态页面可以部署到GithubPages等网站，无需数据库,甚至主机主机支持。目前，hexo在github已拥有7000多start，并拥有许多实用插件以及主题元素，足以见得其受欢迎程度，本来网上已有足够多的教学帖，但大多使用的版本较老或者过为冗余，本文秉承快速入门的初衷，记录了下我在安装部署hexo的经过以及踩过的那些坑。 note：很多童鞋因为SSHkey的关系弄了很久没有成功便放弃了，本文介绍的方法是脱离SSHkey利用https的方式的部署，如需ssh部署的请自行参阅官方文档Reference:[项目地址] [官方文档]","text":"概述Hexo是一款基于node.js的博客框架，使用MarkDown语法进行内容编辑，与传统的wordpress等动态网站相比，博客的渲染生成均在本地完成，所生成的静态页面可以部署到GithubPages等网站，无需数据库,甚至主机主机支持。目前，hexo在github已拥有7000多start，并拥有许多实用插件以及主题元素，足以见得其受欢迎程度，本来网上已有足够多的教学帖，但大多使用的版本较老或者过为冗余，本文秉承快速入门的初衷，记录了下我在安装部署hexo的经过以及踩过的那些坑。 note：很多童鞋因为SSHkey的关系弄了很久没有成功便放弃了，本文介绍的方法是脱离SSHkey利用https的方式的部署，如需ssh部署的请自行参阅官方文档Reference:[项目地址] [官方文档] 安装过程1.github①登录github帐号，新建一个版本仓库。仓库名字为USER_NAME.github.com 这个仓库名称既为你的pages访问链接-&gt;PAGES_URL。 ②我选择了https的方式进行项目部署，每次部署需要输入github帐号密码进行认证，当然你也可以选择ssh的方式,已经有很多人写过了类似的教程，如若需要请自行查阅，我就不再赘述了。进入主页，copy到Http的Clone地址CLONE_URL（即后缀为.git的地址） 准备完成。 2.本地1)git根据系统版本到git下载页下载并安装. 2)nodejs根据系统版本到nodejs下载页下载并安装. 3)配置环境变量，将git nodejs npm配入环境变量。配置成功后确认能执行git node npm指令 3)hexo 包①安装hexo&gt; npm install -g hexo ②初始化hexo路径&gt; hexo init *DIR_NAME* //FLOD_NAME为你创建给hexo的目录名字&gt; cd DIR_NAME; ③早期的hexo包是全家桶，我找了很多之前的教学攻略都是只安装了一个hexo导致组件不全无法预览、部署，查阅了官方的文档发现了解决方案&gt; npm install hexo-renderer-ejs --save //ejs&gt; npm install hexo-renderer-stylus --save&gt; npm install hexo-renderer-stylus --save&gt; npm install hexo-server //服务器模块&gt; npm install consle得到如下输出即为成功&gt; npm installnpm WARN optional dep failed, continuing fsevents@0.3.8npm WARN optional dep failed, continuing fsevents@1.0.5|&gt; dtrace-provider@0.6.0 install *HEXO_HOME*\\node_modules\\hexo\\node_modules\\bunyan\\node_modules\\dtrace-provider&gt; node scripts/install.jshexo-generator-category@0.1.3 node_modules\\hexo-generator-category├── object-assign@2.1.1└── hexo-pagination@0.0.2 (utils-merge@1.0.0)hexo-generator-index@0.1.3 node_modules\\hexo-generator-index├── object-assign@2.1.1└── hexo-pagination@0.0.2 (utils-merge@1.0.0)hexo-generator-tag@0.1.2 node_modules\\hexo-generator-tag├── object-assign@2.1.1└── hexo-pagination@0.0.2 (utils-merge@1.0.0)hexo-generator-archive@0.1.3 node_modules\\hexo-generator-archive├── object-assign@2.1.1└── hexo-pagination@0.0.2 (utils-merge@1.0.0)hexo-server@0.1.2 node_modules\\hexo-server├── object-assign@2.1.1├── open@0.0.5├── mime@1.3.4├── bluebird@2.10.2├── chalk@0.5.1 (ansi-styles@1.1.0, escape-string-regexp@1.0.3, supports-color@0.2.0, strip-ansi@0.3.0, has-ansi@0.1.0)├── morgan@1.6.1 (on-headers@1.0.1, basic-auth@1.0.3, depd@1.0.1, on-finished@2.3.0, debug@2.2.0)├── serve-static@1.10.0 (escape-html@1.0.2, parseurl@1.3.0, send@0.13.0)├── connect@3.4.0 (parseurl@1.3.0, utils-merge@1.0.0, debug@2.2.0, finalhandler@0.4.0)└── compression@1.6.0 (bytes@2.1.0, vary@1.1.0, on-headers@1.0.1, compressible@2.0.6, debug@2.2.0, accepts@1.3.0)hexo-renderer-stylus@0.3.0 node_modules\\hexo-renderer-stylus├── stylus@0.52.4 (css-parse@1.7.0, debug@2.2.0, mkdirp@0.5.1, source-map@0.1.43, glob@3.2.11, sax@0.5.8)└── nib@1.1.0 (stylus@0.49.3)hexo-renderer-marked@0.2.5 node_modules\\hexo-renderer-marked├── object-assign@2.1.1├── marked@0.3.5├── strip-indent@1.0.1 (get-stdin@4.0.1)└── hexo-util@0.1.7 (ent@2.2.0, bluebird@2.10.2, highlight.js@8.9.1)hexo@3.1.1 node_modules\\hexo├── hexo-front-matter@0.2.2├── pretty-hrtime@1.0.1├── abbrev@1.0.7├── archy@1.0.0├── titlecase@1.0.2├── text-table@0.2.0├── strip-indent@1.0.1 (get-stdin@4.0.1)├── tildify@1.1.2 (os-homedir@1.0.1)├── chalk@1.1.1 (escape-string-regexp@1.0.3, supports-color@2.0.0, ansi-styles@2.1.0, strip-ansi@3.0.0, has-ansi@2.0.0)├── hexo-i18n@0.2.1 (sprintf-js@1.0.3)├── minimatch@2.0.10 (brace-expansion@1.1.2)├── through2@1.1.1 (xtend@4.0.1, readable-stream@1.1.13)├── bluebird@2.10.2├── swig-extras@0.0.1 (markdown@0.5.0)├── moment-timezone@0.3.1├── js-yaml@3.4.6 (inherit@2.2.2, esprima@2.7.0, argparse@1.0.3)├── warehouse@1.0.3 (graceful-fs@4.1.2, cuid@1.2.5, JSONStream@1.0.7)├── nunjucks@1.3.4 (chokidar@0.12.6, optimist@0.6.1)├── cheerio@0.19.0 (entities@1.1.1, dom-serializer@0.1.0, css-select@1.0.0, htmlparser2@3.8.3)├── moment@2.10.6├── hexo-cli@0.1.9 (minimist@1.2.0, bluebird@3.0.6)├── lodash@3.10.1├── swig@1.4.2 (optimist@0.6.1, uglify-js@2.4.24)├── hexo-util@0.1.7 (ent@2.2.0, highlight.js@8.9.1)├── bunyan@1.5.1 (safe-json-stringify@1.0.3, dtrace-provider@0.6.0, mv@2.1.1)└── hexo-fs@0.1.5 (escape-string-regexp@1.0.3, graceful-fs@4.1.2, bluebird@3.0.6, chokidar@1.3.0) ④生成页面&gt; hexo generate //生成静态网页 hexo g也可以&gt; hexo server //启动预览服务器 hexo s也可以 note： hexo 启动的时候如果修改了markdown文件会自动生成，也就是说静态页面在启动服务器之后保存修改的文件内容会自动生成，不需要重复④步骤，直接刷新在浏览器中刷新即可查看效果，如果效果不对很有可能是markdown语法错误，这时候查看下console的输出信息。 ⑤ 访问http://localhost:4000/ 你就发现新的大陆了。 写文章&gt;&gt;hexo new &quot;*POST_NAME*&quot; //新建文章//hexo new page &quot;*PAGE_NAME*&quot; 新建页面 执行之后则会在/HEXO_HOME/source/_posts/POST_NAME.md生成一个markdown文件。 打开后已经具有了一个基础模版，在这里加入一个hello wold。 启动服务器，新建的post便出现了 PUSH内容到github①打开/HEXO_HOME/_config.yml在中间找到 deploy内容修改并保存 deploy: type: git repository: *CLONE_URL* //gitclone地址 branch: master ②部署&gt; hexo deploy 输入自己的github帐号密码等待push成功即可 使用浏览器中访问http://USER_NAME.github.io/ (既PAGES_URL) 整个部署过程就完成了，是不是简单到没朋友？ 关于Markdown[wiki]Markdown 是一种轻量级标记语言，语法也十分简单易学。 关于Markdown的语法学习推荐一个我无意中发现的网站Cmd Markdown,左边代码右边效果同步预览上手很快！坑就填到这里，enjoy！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.sequarius.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://www.sequarius.com/tags/github/"},{"name":"博客","slug":"博客","permalink":"https://www.sequarius.com/tags/博客/"},{"name":"gitpages","slug":"gitpages","permalink":"https://www.sequarius.com/tags/gitpages/"}]}]}